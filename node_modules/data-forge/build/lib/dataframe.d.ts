import { IIndex } from './index';
import { ISeries, SelectorWithIndexFn, PredicateFn, ComparerFn, SelectorFn, AggregateFn, Zip2Fn, Zip3Fn, ZipNFn, CallbackFn, JoinFn, GapFillFn } from './series';
/**
 * An object whose fields specify named columns.
 */
export interface IColumnSpec {
    [index: string]: Iterable<any> | ISeries<any, any>;
}
/**
 * Specifes the format per column when converting columns to strings.
 */
export interface IFormatSpec {
    [index: string]: string;
}
/**
 * Specification that defines output columns for a pivot.
 */
export interface IAggregatorSpec {
    [index: string]: (values: ISeries<number, any>) => any;
}
/**
 * Specification for pivoting values in named columns..
 */
export interface IPivotAggregateSpec {
    [index: string]: IAggregatorSpec;
}
/**
 * Defines the configuration for a new column.
 */
export interface IColumnConfig {
    /**
     * The name of the new column.
     */
    name: string;
    /**
     * The series of values for the column.
     */
    series: Iterable<any> | ISeries<any, any>;
}
/**
 * DataFrame configuration.
 */
export interface IDataFrameConfig<IndexT, ValueT> {
    values?: Iterable<ValueT>;
    rows?: Iterable<any[]>;
    index?: Iterable<IndexT>;
    pairs?: Iterable<[IndexT, ValueT]>;
    columnNames?: Iterable<string>;
    baked?: boolean;
    considerAllRows?: boolean;
    columns?: Iterable<IColumnConfig> | IColumnSpec;
}
/**
 * Represents a name column in a dataframe.
 */
export interface IColumn {
    /**
     * The name of the column.
     */
    name: string;
    /**
     * The data type of the column.
     */
    type: string;
    /**
     * The data series from the column.
     */
    series: ISeries<any, any>;
}
/**
 * An object whose fields specify named columns or functions to generate columns.
 */
export interface IColumnGenSpec {
    [index: string]: ISeries<any, any> | SeriesSelectorFn<any, any, any>;
}
/**
 * Specifies how to rename columns.
 */
export interface IColumnRenameSpec {
    [index: string]: string;
}
/**
 * Specifies columns to transform.
 */
export interface IColumnTransformSpec {
    [index: string]: SelectorWithIndexFn<any, any>;
}
/**
 * A spec for aggregating a collection of names columns.
 */
export interface IColumnAggregateSpec {
    [index: string]: AggregateFn<any, any>;
}
/**
 * A selector function that can select a series from a dataframe.
 */
export declare type SeriesSelectorFn<IndexT, DataFrameValueT, SeriesValueT> = (dataFrame: IDataFrame<IndexT, DataFrameValueT>) => ISeries<IndexT, SeriesValueT>;
export declare type DataFrameConfigFn<IndexT, ValueT> = () => IDataFrameConfig<IndexT, ValueT>;
/**
 * Represents the frequency of a type in a series or dataframe.
 */
export interface ITypeFrequency {
    /**
     * Name of the column containing the value.
     */
    Column: string;
    /**
     * The name of the type.
     */
    Type: string;
    /**
     * The frequency of the type's appearance in the series or dataframe.
     */
    Frequency: number;
}
/**
 * Represents the frequency of a value in a series or dataframe.
 */
export interface IValueFrequency {
    /**
     * Name of the column containing the value.
     */
    Column: string;
    /**
     * The value.
     */
    Value: any;
    /**
     * The frequency of the value's appearance in the series or dataframe.
     */
    Frequency: number;
}
/**
 * Records column types in a serialized dataframe.
 */
export interface IColumnTypes {
    [index: string]: string;
}
/**
 * The serialized form of a DataFrame.
 * This is an ordinary JavaScript data structure that can be used to transfer a dataframe across the wire and
 * reinstantiate it on the otherside (this is necessary to maintain a stable column ordering).
 */
export interface ISerializedDataFrame {
    /**
     * The order of columns in the dataframe.
     */
    columnOrder: string[];
    /**
     * Records the columns and their types.
     */
    columns: IColumnTypes;
    /**
     * Rows/values contained in the dataframe..
     */
    values: any[];
}
/**
 * Interface that represents a dataframe.
 * A dataframe contains an indexed sequence of data records.
 * Think of it as a spreadsheet or CSV file in memory.
 *
 * Each data record contains multiple named fields, the value of each field represents one row in a column of data.
 * Each column of data is a named {@link Series}.
 * You think of a dataframe a collection of named data series.
 *
 * @typeparam IndexT The type to use for the index.
 * @typeparam ValueT The type to use for each row/data record.
 */
export interface IDataFrame<IndexT = number, ValueT = any> extends Iterable<ValueT> {
    /**
     * Get an iterator to enumerate the values of the dataframe.
     * Enumerating the iterator forces lazy evaluation to complete.
     * This function is automatically called by `for...of`.
     *
     * @returns An iterator for the dataframe.
     *
     * @example
     * <pre>
     *
     * for (const row of df) {
     *     // ... do something with the row ...
     * }
     * </pre>
     */
    [Symbol.iterator](): Iterator<ValueT>;
    /**
     * Get the names of the columns in the dataframe.
     *
     * @returns Returns an array of the column names in the dataframe.
     */
    getColumnNames(): string[];
    /**
     * Retreive a collection of all columns in the dataframe.
     *
     * @returns Returns a series the columns in the dataframe.
     */
    getColumns(): ISeries<number, IColumn>;
    /**
     * Cast the value of the dataframe to a new type.
     * This operation has no effect but to retype the value that the dataframe contains.
     */
    cast<NewValueT>(): IDataFrame<IndexT, NewValueT>;
    /**
     * Get the index for the dataframe.
     */
    getIndex(): IIndex<IndexT>;
    /**
     * Set a named column as the index of the data-frame.
     *
     * @param columnName - Name or index of the column to set as the index.
     *
     * @returns Returns a new dataframe with the values of a particular named column as the index.
     */
    setIndex<NewIndexT = any>(columnName: string): IDataFrame<NewIndexT, ValueT>;
    /**
     * Apply a new index to the dataframe.
     *
     * @param newIndex The new index to apply to the dataframe.
     *
     * @returns Returns a new dataframe with the specified index attached.
     */
    withIndex<NewIndexT>(newIndex: Iterable<NewIndexT> | SelectorFn<ValueT, NewIndexT>): IDataFrame<NewIndexT, ValueT>;
    /**
     * Resets the index of the dataframe back to the default zero-based sequential integer index.
     *
     * @returns Returns a new dataframe with the index reset to the default zero-based index.
     */
    resetIndex(): IDataFrame<number, ValueT>;
    /**
     * Retreive a series from a column of the dataframe.
     *
     * @param columnName Specifies the name of the column that contains the series to retreive.
     */
    getSeries<SeriesValueT = any>(columnName: string): ISeries<IndexT, SeriesValueT>;
    /**
     * Returns true if the column with the requested name exists in the dataframe.
     *
     * @param columnName - Name of the column to check.
     */
    hasSeries(columnName: string): boolean;
    /**
     *
     * Verify the existance of a column and return it.
     * Throws an exception if the column doesn't exist.
     *
     * @param columnName - Name or index of the column to retreive.
     */
    expectSeries<SeriesValueT>(columnName: string): ISeries<IndexT, SeriesValueT>;
    /**
     * Create a new dataframe with an additional column specified by the passed-in series.
     *
     * @param columnNameOrSpec - The name of the column to add or replace.
     * @param [series] - When columnNameOrSpec is a string that identifies the column to add, this specifies the Series to add to the data-frame or a function that produces a series (given a dataframe).
     *
     * @returns Returns a new dataframe replacing or adding a particular named column.
     */
    withSeries<SeriesValueT>(columnNameOrSpec: string | IColumnGenSpec, series?: ISeries<IndexT, SeriesValueT> | SeriesSelectorFn<IndexT, ValueT, SeriesValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Add a series if it doesn't already exist.
     *
     * @param columnNameOrSpec - The name of the series to add or a column spec that defines the new column.
     * @param series - The series to add to the dataframe. Can also be a function that returns the series.
     *
     * @returns Returns a new dataframe with the specified series added, if the series didn't already exist. Otherwise if the requested series already exists the same dataframe is returned.
     */
    ensureSeries<SeriesValueT>(columnNameOrSpec: string | IColumnGenSpec, series?: ISeries<IndexT, SeriesValueT> | SeriesSelectorFn<IndexT, ValueT, SeriesValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Create a new data-frame from a subset of columns.
     *
     * @param columnNames - Array of column names to include in the new data-frame.
     *
     * @returns Returns a dataframe with a subset of columns from the input dataframe.
     */
    subset<NewValueT = ValueT>(columnNames: string[]): IDataFrame<IndexT, NewValueT>;
    /**
     * Create a new data frame with the requested column or columns dropped.
     *
     * @param columnOrColumns - Specifies the column name (a string) or columns (array of column names) to drop.
     *
     * @returns Returns a new dataframe with a particular name column or columns removed.
     */
    dropSeries<NewValueT = ValueT>(columnOrColumns: string | string[]): IDataFrame<IndexT, NewValueT>;
    /**
     * Create a new data frame with columns reordered.
     * New column names create new columns (with undefined values), omitting existing column names causes those columns to be dropped.
     *
     * @param columnNames - The new order for columns.
     *
     * @returns Returns a new dataframe with columns remapped according to the specified column layout.
     */
    reorderSeries<NewValueT = ValueT>(columnNames: string[]): IDataFrame<IndexT, NewValueT>;
    /**
     * Bring the name column (or columns) to the front, making it (or them) the first column(s) in the data-frame.
     *
     * @param columnOrColumns - Specifies the column or columns to bring to the front.
     *
     * @returns Returns a new dataframe with 1 or more columns bought to the front of the column ordering.
     */
    bringToFront(columnOrColumns: string | string[]): IDataFrame<IndexT, ValueT>;
    /**
     * Bring the name column (or columns) to the back, making it (or them) the last column(s) in the data-frame.
     *
     * @param columnOrColumns - Specifies the column or columns to bring to the back.
     *
     * @returns Returns a new dataframe with 1 or more columns bought to the back of the column ordering.
     */
    bringToBack(columnOrColumns: string | string[]): IDataFrame<IndexT, ValueT>;
    /**
     * Create a new data-frame with renamed series.
     *
     * @param newColumnNames - A column rename spec - maps existing column names to new column names.
     *
     * @returns Returns a new dataframe with columns renamed.
     */
    renameSeries<NewValueT = ValueT>(newColumnNames: IColumnRenameSpec): IDataFrame<IndexT, NewValueT>;
    /**
    * Extract values from the dataframe as an array.
    * This forces lazy evaluation to complete.
    *
    * @returns Returns an array of values contained within the dataframe.
    */
    toArray(): ValueT[];
    /**
     * Retreive the index and values from the DataFrame as an array of pairs.
     * Each pairs is [index, value].
     *
     * @returns Returns an array of pairs that contains the dataframe content. Each pair is a two element array that contains an index and a value.
     */
    toPairs(): ([IndexT, ValueT])[];
    /**
     * Convert the dataframe to a JavaScript object.
     *
     * @param {function} keySelector - Function that selects keys for the resulting object.
     * @param {valueSelector} keySelector - Function that selects values for the resulting object.
     *
     * @returns {object} Returns a JavaScript object generated from the input sequence by the key and value selector funtions.
     */
    toObject<KeyT = any, FieldT = any, OutT = any>(keySelector: (value: ValueT) => KeyT, valueSelector: (value: ValueT) => FieldT): OutT;
    /**
     * Bake the data frame to an array of rows.
     *
     *  @returns Returns an array of rows. Each row is an array of values in column order.
     */
    toRows(): any[][];
    /**
     * Generate a new dataframe based by calling the selector function on each value.
     *
     * @param selector Selector function that transforms each value to create a new dataframe.
     *
     * @returns Returns a new dataframe that has been transformed by the selector function.
     */
    select<ToT>(selector: SelectorWithIndexFn<ValueT, ToT>): IDataFrame<IndexT, ToT>;
    /**
     * Generate a new dataframe based on the results of the selector function.
     *
     * @param selector Selector function that transforms each value into a list of values.
     *
     * @returns  Returns a new dataframe with values that have been produced by the selector function.
     */
    selectMany<ToT>(selector: SelectorWithIndexFn<ValueT, Iterable<ToT>>): IDataFrame<IndexT, ToT>;
    /**
     * Transform one or more columns. This is equivalent to extracting a column, calling 'select' on it,
     * then plugging it back in as the same column.
     *
     * @param columnSelectors - Object with field names for each column to be transformed. Each field you be a selector that transforms that column.
     *
     * @returns Returns a new dataframe with 1 or more columns transformed.
     */
    transformSeries<NewValueT = ValueT>(columnSelectors: IColumnTransformSpec): IDataFrame<IndexT, NewValueT>;
    /**
     * Generate new columns based on existing rows.
     *
     * @param generator - Generator function that transforms each row to a new set of columns.
     *
     * @returns Returns a new dataframe with 1 or more new columns.
     */
    generateSeries<NewValueT = ValueT>(generator: SelectorWithIndexFn<any, any> | IColumnTransformSpec): IDataFrame<IndexT, NewValueT>;
    /**
     * Deflate a data-frame to a series.
     *
     * @param [selector] - Optional selector function that transforms each row to a new sequence of values.
     *
     * @returns Returns a series that was created from the input dataframe.
     */
    deflate<ToT = ValueT>(selector?: SelectorWithIndexFn<ValueT, ToT>): ISeries<IndexT, ToT>;
    /**
     * Inflate a named series in the data-frame to 1 or more new series in the new dataframe.
     *
     * @param columnName - Name or index of the column to retreive.
     * @param [selector] - Optional selector function that transforms each value in the column to new columns. If not specified it is expected that each value in the column is an object whose fields define the new column names.
     *
     * @returns Returns a new dataframe with a column inflated to 1 or more new columns.
     */
    inflateSeries<NewValueT = ValueT>(columnName: string, selector?: SelectorWithIndexFn<IndexT, any>): IDataFrame<IndexT, ValueT>;
    /**
     * Segment a dataframe into 'windows'. Returns a new series. Each value in the new dataframe contains a 'window' (or segment) of the original dataframe.
     * Use select or selectPairs to aggregate.
     *
     * @param period - The number of values in the window.
     *
     * @returns Returns a new series, each value of which is a 'window' (or segment) of the original dataframe.
     */
    window(period: number): ISeries<number, IDataFrame<IndexT, ValueT>>;
    /**
     * Segment a dataframe into 'rolling windows'. Returns a new series. Each value in the new series contains a 'window' (or segment) of the original dataframe.
    *
     * @param period - The number of values in the window.
     *
     * @returns Returns a new series, each value of which is a 'window' (or segment) of the original dataframe.
     */
    rollingWindow(period: number): ISeries<number, IDataFrame<IndexT, ValueT>>;
    /**
     * Groups sequential values into variable length 'windows'.
     *
     * @param comparer - Predicate that compares two values and returns true if they should be in the same window.
     *
     * @returns Returns a series of groups. Each group is itself a dataframe that contains the values in the 'window'.
     */
    variableWindow(comparer: ComparerFn<ValueT, ValueT>): ISeries<number, IDataFrame<IndexT, ValueT>>;
    /**
     * Collapase distinct values that happen to be sequential.
     *
     * @param [selector] - Optional selector function to determine the value used to compare for duplicates.
     *
     * @returns Returns a new dataframe with duplicate values that are sequential removed.
     */
    sequentialDistinct<ToT = ValueT>(selector?: SelectorFn<ValueT, ToT>): IDataFrame<IndexT, ValueT>;
    /**
     * Aggregate the values in the dataframe.
     *
     * @param [seed] - Optional seed value for producing the aggregation.
     * @param selector - Function that takes the seed and then each value in the dataframe and produces the aggregate value.
     *
     * @returns Returns a new value that has been aggregated from the input sequence by the 'selector' function.
     */
    aggregate<ToT = ValueT>(seedOrSelector: AggregateFn<ValueT, ToT> | ToT | IColumnAggregateSpec, selector?: AggregateFn<ValueT, ToT>): ToT;
    /**
     * Skip a number of values in the dataframe.
     *
     * @param numValues - Number of values to skip.     *
     * @returns Returns a new dataframe or dataframe with the specified number of values skipped.
     */
    skip(numValues: number): IDataFrame<IndexT, ValueT>;
    /**
     * Skips values in the series while a condition is met.
     *
     * @param predicate - Return true to indicate the condition met.
     *
     * @returns Returns a new series with all initial sequential values removed that match the predicate.
     */
    skipWhile(predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Skips values in the series until a condition is met.
     *
     * @param predicate - Return true to indicate the condition met.
     *
     * @returns Returns a new series with all initial sequential values removed that don't match the predicate.
     */
    skipUntil(predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Take a number of rows in the series.
     *
     * @param numRows - Number of rows to take.
     *
     * @returns Returns a new series with up to the specified number of values included.
     */
    take(numRows: number): IDataFrame<IndexT, ValueT>;
    /**
     * Take values from the series while a condition is met.
     *
     * @param predicate - Return true to indicate the condition met.
     *
     * @returns Returns a new series that only includes the initial sequential values that have matched the predicate.
     */
    takeWhile(predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Take values from the series until a condition is met.
     *
     * @param predicate - Return true to indicate the condition met.
     *
     * @returns Returns a new series or dataframe that only includes the initial sequential values that have not matched the predicate.
     */
    takeUntil(predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Count the number of values in the series.
     *
     * @returns Returns the count of all values in the series.
     */
    count(): number;
    /**
     * Get the first value of the series.
     *
     * @returns Returns the first value of the series.
     */
    first(): ValueT;
    /**
     * Get the last value of the series.
     *
     * @returns Returns the last value of the series.
     */
    last(): ValueT;
    /**
     * Get the value at a specified index.
     *
     * @param index - Index to for which to retreive the value.
     *
     * @returns Returns the value from the specified index in the sequence or undefined if there is no such index in the series.
     */
    at(index: IndexT): ValueT | undefined;
    /**
     * Get X values from the start of the series.
     *
     * @param numValues - Number of values to take.
     *
     * @returns Returns a new series that has only the specified number of values taken from the start of the input sequence.
     */
    head(numValues: number): IDataFrame<IndexT, ValueT>;
    /**
     * Get X values from the end of the series.
     *
     * @param numValues - Number of values to take.
     *
     * @returns Returns a new series that has only the specified number of values taken from the end of the input sequence.
     */
    tail(numValues: number): IDataFrame<IndexT, ValueT>;
    /**
     * Filter a series by a predicate selector.
     *
     * @param predicate - Predicte function to filter rows of the series.
     *
     * @returns Returns a new series containing only the values that match the predicate.
     */
    where(predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Invoke a callback function for each value in the series.
     *
     * @param callback - The calback to invoke for each value.
     *
     * @returns Returns the input series with no modifications.
     */
    forEach(callback: CallbackFn<ValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Determine if the predicate returns truthy for all values in the series.
     * Returns false as soon as the predicate evaluates to falsy.
     * Returns true if the predicate returns truthy for all values in the series.
     * Returns false if the series is empty.
     *
     * @param predicate - Predicate function that receives each value in turn and returns truthy for a match, otherwise falsy.
     *
     * @returns {boolean} Returns true if the predicate has returned truthy for every value in the sequence, otherwise returns false.
     */
    all(predicate: PredicateFn<ValueT>): boolean;
    /**
     * Determine if the predicate returns truthy for any of the values in the series.
     * Returns true as soon as the predicate returns truthy.
     * Returns false if the predicate never returns truthy.
     * If no predicate is specified the value itself is checked.
     *
     * @param [predicate] - Optional predicate function that receives each value in turn and returns truthy for a match, otherwise falsy.
     *
     * @returns Returns true if the predicate has returned truthy for any value in the sequence, otherwise returns false.
     */
    any(predicate?: PredicateFn<ValueT>): boolean;
    /**
     * Determine if the predicate returns truthy for none of the values in the series.
     * Returns true for an empty series.
     * Returns true if the predicate always returns falsy.
     * Otherwise returns false.
     * If no predicate is specified the value itself is checked.
     *
     * @param [predicate] - Optional predicate function that receives each value in turn and returns truthy for a match, otherwise falsy.
     *
     * @returns Returns true if the predicate has returned truthy for no values in the series, otherwise returns false.
     */
    none(predicate?: PredicateFn<ValueT>): boolean;
    /**
     * Get a new series containing all values starting at and after the specified index value.
     *
     * @param indexValue - The index value to search for before starting the new series.
     *
     * @returns Returns a new series containing all values starting at and after the specified index value.
     */
    startAt(indexValue: IndexT): IDataFrame<IndexT, ValueT>;
    /**
     * Get a new series containing all values up until and including the specified index value (inclusive).
     *
     * @param indexValue - The index value to search for before ending the new series.
     *
     * @returns Returns a new series containing all values up until and including the specified index value.
     */
    endAt(indexValue: IndexT): IDataFrame<IndexT, ValueT>;
    /**
     * Get a new series containing all values up to the specified index value (exclusive).
     *
     * @param indexValue - The index value to search for before ending the new series.
     *
     * @returns Returns a new series containing all values up to the specified inde value.
     */
    before(indexValue: IndexT): IDataFrame<IndexT, ValueT>;
    /**
     * Get a new series containing all values after the specified index value (exclusive).
     *
     * @param indexValue - The index value to search for.
     *
     * @returns Returns a new series containing all values after the specified index value.
     */
    after(indexValue: IndexT): IDataFrame<IndexT, ValueT>;
    /**
     * Get a new dataframe containing all values between the specified index values (inclusive).
     *
     * @param startIndexValue - The index where the new sequence starts.
     * @param endIndexValue - The index where the new sequence ends.
     *
     * @returns Returns a new dataframe containing all values between the specified index values (inclusive).
     */
    between(startIndexValue: IndexT, endIndexValue: IndexT): IDataFrame<IndexT, ValueT>;
    /**
     * Format the dataframe for display as a string.
     * This forces lazy evaluation to complete.
     *
     * @returns Generates and returns a string representation of the dataframe or dataframe.
     */
    toString(): string;
    /**
     * Parse a column with string values to a column with int values.
     *
     * @param columnNameOrNames - Specifies the column name or array of column names to parse.
     *
     * @returns Returns a new dataframe with a particular named column parsed as ints.
     */
    parseInts(columnNameOrNames: string | string[]): IDataFrame<IndexT, ValueT>;
    /**
     * Parse a column with string values to a column with float values.
     *
     * @param columnNameOrNames - Specifies the column name or array of column names to parse.
     *
     * @returns  Returns a new dataframe with a particular named column parsed as floats.
     */
    parseFloats(columnNameOrNames: string | string[]): IDataFrame<IndexT, ValueT>;
    /**
     * Parse a column with string values to a column with date values.
     *
     * @param columnNameOrNames - Specifies the column name or array of column names to parse.
     * @param [formatString] - Optional formatting string for dates.
     *
     * @returns Returns a new dataframe with a particular named column parsed as dates.
     */
    parseDates(columnNameOrNames: string | string[], formatString?: string): IDataFrame<IndexT, ValueT>;
    /**
     * Convert a column of values of different types to a column of string values.
     *
     * @param columnNames - Specifies the column name or array of column names to convert to strings. Can also be a format spec that specifies which columns to convert and what their format should be.
     * @param [formatString] - Optional formatting string for dates.
     *
     * Numeral.js is used for number formatting.
     * http://numeraljs.com/
     *
     * Moment is used for date formatting.
     * https://momentjs.com/docs/#/parsing/string-format/

     * @returns Returns a new dataframe with a particular named column convert to strings.
     */
    toStrings(columnNames: string | string[] | IFormatSpec, formatString?: string): IDataFrame<IndexT, ValueT>;
    /**
     * Produces a new data frame with all string values truncated to the requested maximum length.
     *
     * @param maxLength - The maximum length of the string values after truncation.
     *
     * @returns Returns a new dataframe with all strings truncated to the specified maximum length.
     */
    truncateStrings(maxLength: number): IDataFrame<IndexT, ValueT>;
    /**
     * Forces lazy evaluation to complete and 'bakes' the dataframe into memory.
     *
     * @returns Returns a dataframe that has been 'baked', all lazy evaluation has completed.
     */
    bake(): IDataFrame<IndexT, ValueT>;
    /**
     * Reverse the dataframe.
     *
     * @returns Returns a new dataframe that is the reverse of the input.
     */
    reverse(): IDataFrame<IndexT, ValueT>;
    /**
     * Returns only values in the dataframe that have distinct values.
     *
     * @param selector - Selects the value used to compare for duplicates.
     *
     * @returns Returns a dataframe containing only unique values as determined by the 'selector' function.
     */
    distinct<ToT>(selector?: SelectorFn<ValueT, ToT>): IDataFrame<IndexT, ValueT>;
    /**
     * Group the dataframe according to the selector.
     *
     * @param selector - Selector that defines the value to group by.
     *
     * @returns Returns a series of groups. Each group is a dataframe with values that have been grouped by the 'selector' function.
     */
    groupBy<GroupT>(selector: SelectorWithIndexFn<ValueT, GroupT>): ISeries<number, IDataFrame<IndexT, ValueT>>;
    /**
     * Group sequential values into a series of windows.
     *
     * @param selector - Optional selector that defines the value to group by.
     *
     * @returns Returns a series of groups. Each group is a series with values that have been grouped by the 'selector' function.
     */
    groupSequentialBy<GroupT>(selector?: SelectorFn<ValueT, GroupT>): ISeries<number, IDataFrame<IndexT, ValueT>>;
    /**
     * Concatenate multiple other dataframes onto this dataframe.
     *
     * @param dataframes - Multiple arguments. Each can be either a dataframe or an array of dataframes.
     *
     * @returns Returns a single dataframe concatenated from multiple input dataframes.
     */
    concat(...dataframes: (IDataFrame<IndexT, ValueT>[] | IDataFrame<IndexT, ValueT>)[]): IDataFrame<IndexT, ValueT>;
    /**
    * Zip together multiple dataframes to create a new dataframe.
    * Preserves the index of the first dataframe.
    *
    * @param s2, s3, s4, s4 - Multiple dataframes to zip.
    * @param zipper - Zipper function that produces a new dataframe based on the input dataframes.
    *
    * @returns Returns a single dataframe concatenated from multiple input dataframes.
    */
    zip<Index2T, Value2T, ResultT>(s2: IDataFrame<Index2T, Value2T>, zipper: Zip2Fn<ValueT, Value2T, ResultT>): IDataFrame<IndexT, ResultT>;
    zip<Index2T, Value2T, Index3T, Value3T, ResultT>(s2: IDataFrame<Index2T, Value2T>, s3: IDataFrame<Index3T, Value3T>, zipper: Zip3Fn<ValueT, Value2T, Value3T, ResultT>): IDataFrame<IndexT, ResultT>;
    zip<Index2T, Value2T, Index3T, Value3T, Index4T, Value4T, ResultT>(s2: IDataFrame<Index2T, Value2T>, s3: IDataFrame<Index3T, Value3T>, s4: IDataFrame<Index4T, Value4T>, zipper: Zip3Fn<ValueT, Value2T, Value3T, ResultT>): IDataFrame<IndexT, ResultT>;
    zip<ResultT>(...args: any[]): IDataFrame<IndexT, ResultT>;
    /**
     * Sorts the dataframe by a value defined by the selector (ascending).
     *
     * @param selector Selects the value to sort by.
     *
     * @returns Returns a new ordered dataframe that has been sorted by the value returned by the selector.
     */
    orderBy<SortT>(selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedDataFrame<IndexT, ValueT, SortT>;
    /**
     * Sorts the dataframe by a value defined by the selector (descending).
     *
     * @param selector Selects the value to sort by.
     *
     * @returns Returns a new ordered dataframe that has been sorted by the value returned by the selector.
     */
    orderByDescending<SortT>(selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedDataFrame<IndexT, ValueT, SortT>;
    /**
     * Returns the unique union of values between two dataframes.
     *
     * @param other - The other dataframe to combine.
     * @param [selector] - Optional function that selects the value to compare to detemrine distinctness.
     *
     * @returns Returns the union of two dataframes.
     */
    union<KeyT = ValueT>(other: IDataFrame<IndexT, ValueT>, selector?: SelectorFn<ValueT, KeyT>): IDataFrame<IndexT, ValueT>;
    /**
     * Returns the intersection of values between two dataframes.
     *
     * @param inner - The other dataframes to combine.
     * @param [outerSelector] - Optional function to select the key for matching the two dataframes.
     * @param [innerSelector] - Optional function to select the key for matching the two dataframes.
     *
     * @returns Returns the intersection of two dataframes.
     */
    intersection<InnerIndexT = IndexT, InnerValueT = ValueT, KeyT = ValueT>(inner: IDataFrame<InnerIndexT, InnerValueT>, outerSelector?: SelectorFn<ValueT, KeyT>, innerSelector?: SelectorFn<InnerValueT, KeyT>): IDataFrame<IndexT, ValueT>;
    /**
     * Returns the exception of values between two dataframes.
     *
     * @param inner - The other dataframe to combine.
     * @param [outerSelector] - Optional function to select the key for matching the two dataframes.
     * @param [innerSelector] - Optional function to select the key for matching the two dataframes.
     *
     * @returns Returns the difference between the two dataframes.
     */
    except<InnerIndexT = IndexT, InnerValueT = ValueT, KeyT = ValueT>(inner: IDataFrame<InnerIndexT, InnerValueT>, outerSelector?: SelectorFn<ValueT, KeyT>, innerSelector?: SelectorFn<InnerValueT, KeyT>): IDataFrame<IndexT, ValueT>;
    /**
      * Correlates the elements of two dataframes on matching keys.
      *
      * @param this - The outer dataframe to join.
      * @param inner - The inner dataframe to join.
      * @param outerKeySelector - Selector that chooses the join key from the outer sequence.
      * @param innerKeySelector - Selector that chooses the join key from the inner sequence.
      * @param resultSelector - Selector that defines how to merge outer and inner values.
      *
      * @returns Returns the joined dataframe.
      */
    join<KeyT, InnerIndexT, InnerValueT, ResultValueT>(inner: IDataFrame<InnerIndexT, InnerValueT>, outerKeySelector: SelectorFn<ValueT, KeyT>, innerKeySelector: SelectorFn<InnerValueT, KeyT>, resultSelector: JoinFn<ValueT, InnerValueT, ResultValueT>): IDataFrame<number, ResultValueT>;
    /**
     * Performs an outer join on two dataframes. Correlates the elements based on matching keys.
     * Includes elements from both dataframes that have no correlation in the other dataframe.
     *
     * @param this - The outer dataframe to join.
     * @param inner - The inner dataframe to join.
     * @param outerKeySelector - Selector that chooses the join key from the outer sequence.
     * @param innerKeySelector - Selector that chooses the join key from the inner sequence.
     * @param resultSelector - Selector that defines how to merge outer and inner values.
     *
     * Implementation from here:
     *
     * 	http://blogs.geniuscode.net/RyanDHatch/?p=116
     *
     * @returns Returns the joined dataframe.
     */
    joinOuter<KeyT, InnerIndexT, InnerValueT, ResultValueT>(inner: IDataFrame<InnerIndexT, InnerValueT>, outerKeySelector: SelectorFn<ValueT, KeyT>, innerKeySelector: SelectorFn<InnerValueT, KeyT>, resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>): IDataFrame<number, ResultValueT>;
    /**
     * Performs a left outer join on two dataframe. Correlates the elements based on matching keys.
     * Includes left elements that have no correlation.
     *
     * @param this - The outer dataframe to join.
     * @param inner - The inner dataframe to join.
     * @param outerKeySelector - Selector that chooses the join key from the outer sequence.
     * @param innerKeySelector - Selector that chooses the join key from the inner sequence.
     * @param resultSelector - Selector that defines how to merge outer and inner values.
     *
     * Implementation from here:
     *
     * 	http://blogs.geniuscode.net/RyanDHatch/?p=116
     *
     * @returns Returns the joined dataframe.
     */
    joinOuterLeft<KeyT, InnerIndexT, InnerValueT, ResultValueT>(inner: IDataFrame<InnerIndexT, InnerValueT>, outerKeySelector: SelectorFn<ValueT, KeyT>, innerKeySelector: SelectorFn<InnerValueT, KeyT>, resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>): IDataFrame<number, ResultValueT>;
    /**
     * Performs a right outer join on two dataframes. Correlates the elements based on matching keys.
     * Includes right elements that have no correlation.
     *
     * @param this - The outer dataframe to join.
     * @param inner - The inner dataframe to join.
     * @param outerKeySelector - Selector that chooses the join key from the outer sequence.
     * @param innerKeySelector - Selector that chooses the join key from the inner sequence.
     * @param resultSelector - Selector that defines how to merge outer and inner values.
     *
     * Implementation from here:
     *
     * 	http://blogs.geniuscode.net/RyanDHatch/?p=116
     *
     * @returns Returns the joined dataframe.
     */
    joinOuterRight<KeyT, InnerIndexT, InnerValueT, ResultValueT>(inner: IDataFrame<InnerIndexT, InnerValueT>, outerKeySelector: SelectorFn<ValueT, KeyT>, innerKeySelector: SelectorFn<InnerValueT, KeyT>, resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>): IDataFrame<number, ResultValueT>;
    /**
     * Reshape (or pivot) a table based on column values.
     * This effiectively a short-hand for multiple grouping operations and an aggregation.
     *
     * @param columnOrColumns - Column name whose values make the new DataFrame's columns.
     * @param valueColumnNameOrSpec - Column name or column spec that defines the columns whose values should be aggregated.
     * @param [aggregator] - Optional function used to aggregate pivotted vales.
     *
     * @returns Returns a new dataframe that has been pivoted based on a particular column's values.
     */
    pivot<NewValueT = ValueT>(columnOrColumns: string | Iterable<string>, valueColumnNameOrSpec: string | IPivotAggregateSpec, aggregator?: (values: ISeries<number, any>) => any): IDataFrame<number, NewValueT>;
    /**
     * Insert a pair at the start of the dataframe.
     *
     * @param pair - The pair to insert.
     *
     * @returns Returns a new dataframe with the specified pair inserted.
     */
    insertPair(pair: [IndexT, ValueT]): IDataFrame<IndexT, ValueT>;
    /**
     * Append a pair to the end of a dataframe.
     *
     * @param pair - The pair to append.
     *
     * @returns Returns a new dataframe with the specified pair appended.
     */
    appendPair(pair: [IndexT, ValueT]): IDataFrame<IndexT, ValueT>;
    /**
     * Fill gaps in a dataframe.
     *
     * @param comparer - Comparer that is passed pairA and pairB, two consecutive rows, return truthy if there is a gap between the rows, or falsey if there is no gap.
     * @param generator - Generator that is passed pairA and pairB, two consecutive rows, returns an array of pairs that fills the gap between the rows.
     *
     * @returns Returns a new dataframe with gaps filled in.
     */
    fillGaps(comparer: ComparerFn<[IndexT, ValueT], [IndexT, ValueT]>, generator: GapFillFn<[IndexT, ValueT], [IndexT, ValueT]>): IDataFrame<IndexT, ValueT>;
    /**
     * Returns the specified default sequence if the dataframe is empty.
     *
     * @param defaultSequence - Default sequence to return if the dataframe is empty.
     *
     * @returns Returns 'defaultSequence' if the dataframe is empty.
     */
    defaultIfEmpty(defaultSequence: ValueT[] | IDataFrame<IndexT, ValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Detect the types of the values in the dataframe.
     *
     * @returns Returns a dataframe that describes the data types contained in the input series or dataframe.
     */
    detectTypes(): IDataFrame<number, ITypeFrequency>;
    /**
     * Detect the frequency of the values in the dataframe.
     *
     * @returns Returns a dataframe that describes the values contained in the dataframe.
     */
    detectValues(): IDataFrame<number, IValueFrequency>;
    /**
     * Serialize the dataframe to JSON.
     *
     *  @returns Returns a JSON format string representing the dataframe.
     */
    toJSON(): string;
    /**
     * Serialize the dataframe to CSV.
     *
     *  @returns Returns a CSV format string representing the dataframe.
     */
    toCSV(): string;
    /**
     * Treat the dataframe as CSV data for purposes of serialization.
     *
     * @returns Returns an object that represents the dataframe for serialization in the CSV format. Call `writeFile`, `writeFileSync` to output the dataframe via different media.
     */
    asCSV(): ICsvSerializer;
    /**
     * Treat the dataframe as JSON data for purposes of serialization.
     *
     * @returns Returns an object that can serialize the dataframe in the JSON format. Call `writeFile` or `writeFileSync` to output the dataframe via different media.
     */
    asJSON(): IJsonSerializer;
    /**
     * Serialize the dataframe to HTML.
     *
     *  @returns Returns a HTML format string representing the dataframe.
     */
    toHTML(): string;
    /**
     * Serialize the dataframe to an ordinary JavaScript data structure.
     */
    serialize(): any;
}
/**
 * Interface to a dataframe that has been ordered.
 */
export interface IOrderedDataFrame<IndexT = number, ValueT = any, SortT = any> extends IDataFrame<IndexT, ValueT> {
    /**
     * Performs additional sorting (ascending).
     *
     * @param selector Selects the value to sort by.
     *
     * @returns Returns a new dataframe has been additionally sorted by the value returned by the selector.
     */
    thenBy<SortT>(selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedDataFrame<IndexT, ValueT, SortT>;
    /**
     * Performs additional sorting (descending).
     *
     * @param selector Selects the value to sort by.
     *
     * @returns Returns a new dataframe has been additionally sorted by the value returned by the selector.
     */
    thenByDescending<SortT>(selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedDataFrame<IndexT, ValueT, SortT>;
}
/**
 * Class that represents a dataframe.
 * A dataframe contains an indexed sequence of data records.
 * Think of it as a spreadsheet or CSV file in memory.
 *
 * Each data record contains multiple named fields, the value of each field represents one row in a column of data.
 * Each column of data is a named {@link Series}.
 * You think of a dataframe a collection of named data series.
 *
 * @typeparam IndexT The type to use for the index.
 * @typeparam ValueT The type to use for each row/data record.
 */
export declare class DataFrame<IndexT = number, ValueT = any> implements IDataFrame<IndexT, ValueT> {
    private configFn;
    private content;
    private static readonly defaultCountIterable;
    private static readonly defaultEmptyIterable;
    private static initFromArray<IndexT, ValueT>(arr);
    private static initEmpty<IndexT, ValueT>();
    private static initColumnNames(inputColumnNames);
    private static checkIterable<T>(input, fieldName);
    private static initFromConfig<IndexT, ValueT>(config);
    /**
     * Create a dataframe.
     *
     * @param config This can be an array, a configuration object or a function that lazily produces a configuration object.
     *
     * It can be an array that specifies the data records that the dataframe contains.
     *
     * It can be a {@link IDataFrameConfig} that defines the data and configuration of the dataframe.
     *
     * Or it can be a function that lazily produces a {@link IDataFrameConfig}.
     *
     * @example
     * <pre>
     *
     * const df = new DataFrame();
     * </pre>
     *
     * @example
     * <pre>
     *
     * const df = new DataFrame([10, 20, 30, 40]);
     * </pre>
     *
     * @example
     * <pre>
     *
     * const df = new DataFrame({ index: [1, 2, 3, 4], values: [10, 20, 30, 40]});
     * </pre>
     *
     * @example
     * <pre>
     *
     * const lazyInit = () => ({ index: [1, 2, 3, 4], values: [10, 20, 30, 40] });
     * const df = new DataFrame(lazyInit);
     * </pre>
     */
    constructor(config?: Iterable<ValueT> | IDataFrameConfig<IndexT, ValueT> | DataFrameConfigFn<IndexT, ValueT>);
    private lazyInit();
    private getContent();
    /**
     * Get an iterator to enumerate the values of the dataframe.
     * Enumerating the iterator forces lazy evaluation to complete.
     * This function is automatically called by `for...of`.
     *
     * @returns An iterator for the dataframe.
     *
     * @example
     * <pre>
     *
     * for (const row of df) {
     *     // ... do something with the row ...
     * }
     * </pre>
     */
    [Symbol.iterator](): Iterator<any>;
    /**
     * Get the names of the columns in the dataframe.
     *
     * @returns Returns an array of the column names in the dataframe.
     *
     * @example
     * <pre>
     *
     * console.log(df.getColumnNames());
     * </pre>
     */
    getColumnNames(): string[];
    /**
     * Retreive the collection of all columns in the dataframe.
     *
     * @returns Returns a {@link Series} containing the names of the columns in the dataframe.
     *
     * @example
     * <pre>
     *
     * for (const column in df.getColummns()) {
     *      console.log("Column name: ");
     *      console.log(column.name);
     *
     *      console.log("Data:");
     *      console.log(column.series.toArray());
     * }
     * </pre>
     */
    getColumns(): ISeries<number, IColumn>;
    /**
     * Cast the value of the dataframe to a new type.
     * This operation has no effect but to retype the value that the dataframe contains.
     *
     * @returns The same dataframe, but with the type changed.
     *
     * @example
     * <pre>
     *
     * const castDf = df.cast<SomeOtherType>();
     * </pre>
     */
    cast<NewValueT>(): IDataFrame<IndexT, NewValueT>;
    /**
     * Get the index for the dataframe.
     *
     * @returns The {@link Index} for the dataframe.
     *
     * @example
     * <pre>
     *
     * const index = df.getIndex();
     * </pre>
     */
    getIndex(): IIndex<IndexT>;
    /**
     * Set a named column as the {@link Index} of the dataframe.
     *
     * @param columnName Name of the column to use as the new {@link Index} of the returned dataframe.
     *
     * @returns Returns a new dataframe with the values of the specified column as the new {@link Index}.
     *
     * @example
     * <pre>
     *
     * const indexedDf = df.setIndex("SomeColumn");
     * </pre>
     */
    setIndex<NewIndexT = any>(columnName: string): IDataFrame<NewIndexT, ValueT>;
    /**
     * Apply a new {@link Index} to the dataframe.
     *
     * @param newIndex The new array or iterable to be the new {@link Index} of the dataframe. Can also be a selector to choose the {@link Index} for each row in the dataframe.
     *
     * @returns Returns a new dataframe or dataframe with the specified {@link Index} attached.
     *
     * @example
     * <pre>
     *
     * const indexedDf = df.withIndex([10, 20, 30]);
     * </pre>
     *
     * @example
     * <pre>
     *
     * const indexedDf = df.withIndex(df.getSeries("SomeColumn"));
     * </pre>
     *
     * @example
     * <pre>
     *
     * const indexedDf = df.withIndex(row => row.SomeColumn);
     * </pre>
     *
     * @example
     * <pre>
     *
     * const indexedDf = df.withIndex(row => row.SomeColumn + 20);
     * </pre>
     */
    withIndex<NewIndexT>(newIndex: Iterable<NewIndexT> | SelectorFn<ValueT, NewIndexT>): IDataFrame<NewIndexT, ValueT>;
    /**
     * Resets the {@link Index} of the dataframe back to the default zero-based sequential integer index.
     *
     * @returns Returns a new dataframe with the {@link Index} reset to the default zero-based index.
     *
     * @example
     * <pre>
     *
     * const dfWithResetIndex = df.resetIndex();
     * </pre>
     */
    resetIndex(): IDataFrame<number, ValueT>;
    /**
     * Extract a {@link Series} from a named column in the dataframe.
     *
     * @param columnName Specifies the name of the column that contains the {@link Series} to retreive.
     *
     * @returns Returns the {@link Series} extracted from the named column in the dataframe.
     *
     * @example
     * <pre>
     *
     * const series = df.getSeries("SomeColumn");
     * </pre>
     */
    getSeries<SeriesValueT = any>(columnName: string): ISeries<IndexT, SeriesValueT>;
    /**
     * Determine if the dataframe contains a {@link Series} the specified named column.
     *
     * @param columnName Name of the column to check for.
     *
     * @returns Returns true if the dataframe contains the requested {@link Series}, otherwise returns false.
     *
     * @example
     * <pre>
     *
     * if (df.hasSeries("SomeColumn")) {
     *      // ... the dataframe contains a series with the specified column name ...
     * }
     * </pre>
     */
    hasSeries(columnName: string): boolean;
    /**
     *
     * Verify the existence of a name column and extracts the {@link Series} for it.
     * Throws an exception if the requested column doesn't exist.
     *
     * @param columnName Name of the column to extract.
     *
     * @returns Returns the {@link Series} for the column if it exists, otherwise it throws an exception.
     *
     * @example
     * <pre>
     *
     * try {
     *      const series = df.expectSeries("SomeColumn");
     *      // ... do something with the series ...
     * }
     * catch (err) {
     *      // ... the dataframe doesn't contain the column "SomeColumn" ...
     * }
     * </pre>
     */
    expectSeries<SeriesValueT>(columnName: string): ISeries<IndexT, SeriesValueT>;
    /**
     * Create a new dataframe with a replaced or additional column specified by the passed-in series.
     *
     * @param columnNameOrSpec The name of the column to add or replace or a {@link IColumnGenSpec} that defines the columns to add.
     * @param [series] When columnNameOrSpec is a string that identifies the column to add, this specifies the {@link Series} to add to the dataframe or a function that produces a series (given a dataframe).
     *
     * @returns Returns a new dataframe replacing or adding a particular named column.
     *
     * @example
     * <pre>
     *
     * const modifiedDf = df.withSeries("ANewColumn", new Series([1, 2, 3]));
     * </pre>
     *
     * @example
     * <pre>
     *
     * const modifiedDf = df.withSeries("ANewColumn", df =>
     *      df.getSeries("SourceData").select(aTransformation)
     * );
     * </pre>
     *
     * @example
     * <pre>
     *
     * const modifiedDf = df.withSeries({
     *      ANewColumn: new Series([1, 2, 3]),
     *      SomeOtherColumn: new Series([10, 20, 30])
     * });
     * <pre>
     *
     * @example
     * <pre>
     *
     * const modifiedDf = df.withSeries({
     *      ANewColumn: df => df.getSeries("SourceData").select(aTransformation))
     * });
     * <pre>
     */
    withSeries<SeriesValueT>(columnNameOrSpec: string | IColumnGenSpec, series?: ISeries<IndexT, SeriesValueT> | SeriesSelectorFn<IndexT, ValueT, SeriesValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Add a series to the dataframe, but only if it doesn't already exist.
     *
     * @param columnNameOrSpec The name of the series to add or a {@link IColumnGenSpec} that specifies the columns to add.
     * @param [series] If columnNameOrSpec is a string that specifies the name of the series to add, this specifies the actual {@link Series} to add or a selector that generates the series given the dataframe.
     *
     * @returns Returns a new dataframe with the specified series added, if the series didn't already exist. Otherwise if the requested series already exists the same dataframe is returned.
     *
     * @example
     * <pre>
     *
     * const updatedDf = df.ensureSeries("ANewColumn", new Series([1, 2, 3]));
     * </pre>
     *
     * @example
     * <pre>
     *
     * const updatedDf = df.ensureSeries("ANewColumn", df =>
     *      df.getSeries("AnExistingSeries").select(aTransformation)
     * );
     * </pre>
     *
     * @example
     * <pre>
     *
     * const modifiedDf = df.ensureSeries({
     *      ANewColumn: new Series([1, 2, 3]),
     *      SomeOtherColumn: new Series([10, 20, 30])
     * });
     * <pre>
     *
     * @example
     * <pre>
     *
     * const modifiedDf = df.ensureSeries({
     *      ANewColumn: df => df.getSeries("SourceData").select(aTransformation))
     * });
     * <pre>
     * */
    ensureSeries<SeriesValueT>(columnNameOrSpec: string | IColumnGenSpec, series?: ISeries<IndexT, SeriesValueT> | SeriesSelectorFn<IndexT, ValueT, SeriesValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Create a new dataframe with just a subset of columns.
     *
     * @param columnNames Array of column names to include in the new dataframe.
     *
     * @returns Returns a dataframe with a subset of columns from the original dataframe.
     *
     * @example
     * <pre>
     * const subsetDf = df.subset(["ColumnA", "ColumnB"]);
     * </pre>
     */
    subset<NewValueT = ValueT>(columnNames: string[]): IDataFrame<IndexT, NewValueT>;
    /**
     * Create a new dataframe with the requested column or columns dropped.
     *
     * @param columnOrColumns Specifies the column name (a string) or columns (array of strings) to drop.
     *
     * @returns Returns a new dataframe with a particular named column or columns removed.
     *
     * @example
     * <pre>
     * const modifiedDf = df.dropSeries("SomeColumn");
     * </pre>
     *
     * @example
     * <pre>
     * const modifiedDf = df.dropSeries(["ColumnA", "ColumnB"]);
     * </pre>
     */
    dropSeries<NewValueT = ValueT>(columnOrColumns: string | string[]): IDataFrame<IndexT, NewValueT>;
    /**
     * Create a new dataframe with columns reordered.
     * New column names create new columns (with undefined values), omitting existing column names causes those columns to be dropped.
     *
     * @param columnNames Specifies the new order for columns.
     *
     * @returns Returns a new dataframe with columns reodered according to the order of the array of column names that is passed in.
     *
     * @example
     * <pre>
     * const reorderedDf = df.reorderSeries(["FirstColumn", "SecondColumn", "etc"]);
     * </pre>
     */
    reorderSeries<NewValueT = ValueT>(columnNames: string[]): IDataFrame<IndexT, NewValueT>;
    /**
     * Bring the column(s) with specified name(s) to the front of the column order, making it (or them) the first column(s) in the output dataframe.
     *
     * @param columnOrColumns Specifies the column or columns to bring to the front.
     *
     * @returns Returns a new dataframe with 1 or more columns bought to the front of the column ordering.
     *
     * @example
     * <pre>
     * const modifiedDf = df.bringToFront("NewFirstColumn");
     * </pre>
     *
     * @example
     * <pre>
     * const modifiedDf = df.bringToFront(["NewFirstColumn", "NewSecondColumn"]);
     * </pre>
     */
    bringToFront(columnOrColumns: string | string[]): IDataFrame<IndexT, ValueT>;
    /**
     * Bring the column(s) with specified name(s) to the back of the column order, making it (or them) the last column(s) in the output dataframe.
     *
     * @param columnOrColumns Specifies the column or columns to bring to the back.
     *
     * @returns Returns a new dataframe with 1 or more columns bought to the back of the column ordering.
     *
     * @example
     * <pre>
     * const modifiedDf = df.bringToBack("NewLastColumn");
     * </pre>
     *
     * @example
     * <pre>
     * const modifiedDf = df.bringToBack(["NewSecondLastCollumn, ""NewLastColumn"]);
     * </pre>
     */
    bringToBack(columnOrColumns: string | string[]): IDataFrame<IndexT, ValueT>;
    /**
     * Create a new dataframe with 1 or more columns renamed.
     *
     * @param newColumnNames A column rename spec - a JavaScript hash that maps existing column names to new column names.
     *
     * @returns Returns a new dataframe with specified columns renamed.
     *
     * @example
     * <pre>
     *
     * const renamedDf = df.renameSeries({ OldColumnName, NewColumnName });
     * </pre>
     *
     * @example
     * <pre>
     *
     * const renamedDf = df.renameSeries({
     *      Column1: ColumnA,
     *      Column2: ColumnB
     * });
     * </pre>
     */
    renameSeries<NewValueT = ValueT>(newColumnNames: IColumnRenameSpec): IDataFrame<IndexT, NewValueT>;
    /**
    * Extract values from the dataframe as an array.
    * This forces lazy evaluation to complete.
    *
    * @returns Returns an array of the values contained within the dataframe.
    *
    * @example
    * <pre>
    * const values = df.toArray();
    * </pre>
    */
    toArray(): any[];
    /**
     * Retreive the index and values pairs from the dataframe as an array.
     * Each pair is [index, value].
     * This forces lazy evaluation to complete.
     *
     * @returns Returns an array of pairs that contains the dataframe content. Each pair is a two element array that contains an index and a value.
     *
     * @example
     * <pre>
     * const pairs = df.toPairs();
     * </pre>
     */
    toPairs(): ([IndexT, ValueT])[];
    /**
     * Convert the dataframe to a JavaScript object.
     *
     * @param keySelector Function that selects keys for the resulting object.
     * @param valueSelector Function that selects values for the resulting object.
     *
     * @returns Returns a JavaScript object generated from the dataframe by applying the key and value selector functions.
     *
     * @example
     * <pre>
     *
     * const someObject = df.toObject(
     *      row => row.SomeColumn, // Specify the column to use for fields in the object.
     *      row => row.SomeOtherColumn // Specifi the column to use as the value for each field.
     * );
     * </pre>
     */
    toObject<KeyT = any, FieldT = any, OutT = any>(keySelector: (value: ValueT) => KeyT, valueSelector: (value: ValueT) => FieldT): OutT;
    /**
     * Bake the data frame to an array of rows were each rows is an array of values in column order.
     *
     * @returns Returns an array of rows. Each row is an array of values in column order.
     *
     * @example
     * <pre>
     * const rows = df.toRows();
     * </pre>
     */
    toRows(): any[][];
    /**
     * Generates a new dataframe by repeatedly calling a selector function on each row in the original dataframe.
     *
     * @param selector Selector function that transforms each row to create the new dataframe.
     *
     * @returns Returns a new dataframe that has been transformed by the selector function.
     *
     * @example
     * <pre>
     *
     * function transformRow (inputRow) {
     *      const outputRow = {
     *          // ... construct output row derived from input row ...
     *      };
     *
     *      return outputRow;
     * }
     *
     * const modifiedDf = df.select(row => transformRow(row));
     * </pre>
     */
    select<ToT>(selector: SelectorWithIndexFn<ValueT, ToT>): IDataFrame<IndexT, ToT>;
    /**
     * Generates a new dataframe by repeatedly calling a selector function on each row in the original dataframe.
     *
     * In this case the selector function produces a collection of output rows that are flattened to create the new dataframe.
     *
     * @param selector Selector function that transforms each row into a collection of output rows.
     *
     * @returns  Returns a new dataframe with rows that have been produced by the selector function.
     *
     * @example
     * <pre>
     *
     * function produceOutputRows (inputRow) {
     *      const outputRows = [];
     *      while (someCondition) {     *
     *          // ... generate zero or more output rows ...
     *          outputRows.push(... some generated row ...);
     *      }
     *      return outputRows;
     * }
     *
     * const modifiedDf = df.selectMany(row => produceOutputRows(row));
     * </pre>
     */
    selectMany<ToT>(selector: SelectorWithIndexFn<ValueT, Iterable<ToT>>): IDataFrame<IndexT, ToT>;
    /**
     * Transform one or more columns.
     *
     * This is equivalent to extracting a {@link Series} with {@link getSeries}, then transforming it with {@link Series.select},
     * and finally plugging it back in as the same column using {@link withSeries}.
     *
     * @param columnSelectors Object with field names for each column to be transformed. Each field specifies a selector function that transforms that column.
     *
     * @returns Returns a new dataframe with 1 or more columns transformed.
     *
     * @example
     * <pre>
     *
     * const modifiedDf = df.transformSeries({
     *      AColumnToTransform: columnValue => transformRow(columnValue)
     * });
     * </pre>
     *
     * @example
     * <pre>
     *
     * const modifiedDf = df.transformSeries({
     *      ColumnA: columnValue => transformColumnA(columnValue),
     *      ColumnB: columnValue => transformColumnB(columnValue)
     * });
     * </pre>
     */
    transformSeries<NewValueT = ValueT>(columnSelectors: IColumnTransformSpec): IDataFrame<IndexT, NewValueT>;
    /**
     * Generate new columns based on existing rows.
     *
     * This is equivalent to calling {@link select} to transform the original dataframe to a new dataframe with different column,
     * then using {@link withSeries} to merge each the of both the new and original dataframes.
     *
     * @param generator Generator function that transforms each row to produce 1 or more new columns.
     * Or use a column spec that has fields for each column, the fields specify a generate function that produces the value for each new column.
     *
     * @returns Returns a new dataframe with 1 or more new columns.
     *
     * @example
     * <pre>
     *
     * function produceNewColumns (inputRow) {
     *      const newColumns = {
     *          // ... specify new columns and their values based on the input row ...
     *      };
     *
     *      return newColumns;
     * };
     *
     * const dfWithNewSeries = df.generateSeries(row => produceNewColumns(row));
     * </pre>
     *
     * @example
     * <pre>
     *
     * const dfWithNewSeries = df.generateSeries({
     *      NewColumnA: row => produceNewColumnA(row),
     *      NewColumnB: row => produceNewColumnB(row),
     * })
     * </pre>
     */
    generateSeries<NewValueT = ValueT>(generator: SelectorWithIndexFn<any, any> | IColumnTransformSpec): IDataFrame<IndexT, NewValueT>;
    /**
     * Converts (deflates) a dataframe to a {@link Series}.
     *
     * @param [selector] Optional selector function that transforms each row to produce the series.
     *
     * @returns Returns a series that was created from the deflated from  the original dataframe.
     *
     * @example
     * <pre>
     *
     * const series = df.deflate(); // Deflate to a series of object.
     * </pre>
     *
     * @example
     * <pre>
     *
     * const series = df.deflate(row => row.SomeColumn); // Extract a particular column.
     * </pre>
     */
    deflate<ToT = ValueT>(selector?: SelectorWithIndexFn<ValueT, ToT>): ISeries<IndexT, ToT>;
    /**
     * Inflate a named {@link Series} in the dataframe to 1 or more new series in the new dataframe.
     *
     * This is the equivalent of extracting the series using {@link getSeries}, transforming them with {@link Series.select}
     * and then running {@link Series.inflate} to create a new dataframe, then merging each column of the new dataframe
     *  into the original dataframe using {@link withSeries}.
     *
     * @param columnName Name of the series to inflate.
     * @param [selector] Optional selector function that transforms each value in the column to new columns. If not specified it is expected that each value in the column is an object whose fields define the new column names.
     *
     * @returns Returns a new dataframe with a column inflated to 1 or more new columns.
     *
     * @example
     * <pre>
     *
     * function newColumnGenerator (row) {
     *      const newColumns = {
     *          // ... create 1 field per new column ...
     *      };
     *
     *      return row;
     * }
     *
     * const dfWithNewSeries = df.inflateSeries("SomeColumn", newColumnGenerator);
     * </pre>
     */
    inflateSeries<NewValueT = ValueT>(columnName: string, selector?: SelectorWithIndexFn<IndexT, any>): IDataFrame<IndexT, ValueT>;
    /**
     * Partition a dataframe into a {@link Series} of *data windows*.
     * Each value in the new series is a rolling chunk of data from the original dataframe.
     *
     * @param period The number of data rows to include in each data window.
     *
     * @returns Returns a new series, each value of which is a chunk of the original dataframe.
     *
     * @example
     * <pre>
     *
     * const windows = df.window(2); // Get values in pairs.
     * const pctIncrease = windows.select(pair => (pair.last() - pair.first()) / pair.first());
     * console.log(pctIncrease.toString());
     * </pre>
     *
     * @example
     * <pre>
     *
     * const salesDf = ... // Daily sales data.
     * const weeklySales = salesDf.window(7); // Partition up into weekly data sets.
     * console.log(weeklySales.toString());
     * </pre>
     */
    window(period: number): ISeries<number, IDataFrame<IndexT, ValueT>>;
    /**
     * Partition a dataframe into a {@link Series} of *rolling data windows*.
     * Each value in the new series is a rolling chunk of data from the original dataframe.
     *
     * @param period The number of data rows to include in each data window.
     *
     * @returns Returns a new series, each value of which is a rolling chunk of the original dataframe.
     *
     * @example
     * <pre>
     *
     * const salesDf = ... // Daily sales data.
     * const rollingWeeklySales = salesDf.rollingWindow(7); // Get rolling window over weekly sales data.
     * console.log(rollingWeeklySales.toString());
     * </pre>
     */
    rollingWindow(period: number): ISeries<number, IDataFrame<IndexT, ValueT>>;
    /**
     * Partition a dataframe into a {@link Series} of variable-length *data windows*
     * where the divisions between the data chunks are
     * defined by a user-provided *comparer* function.
     *
     * @param comparer Function that compares two adjacent data rows and returns true if they should be in the same window.
     *
     * @returns Returns a new series, each value of which is a chunk of data from the original dataframe.
     *
     * @example
     * <pre>
     *
     * function rowComparer (rowA, rowB) {
     *      if (... rowA should be in the same data window as rowB ...) {
     *          return true;
     *      }
     *      else {
     *          return false;
     *      }
     * };
     *
     * const variableWindows = df.variableWindow(rowComparer);
     */
    variableWindow(comparer: ComparerFn<ValueT, ValueT>): ISeries<number, IDataFrame<IndexT, ValueT>>;
    /**
     * Eliminates adjacent duplicate rows.
     *
     * For each group of adjacent values that are equivalent only returns the last index/row for the group,
     * thus ajacent equivalent rows are collapsed down to the last row.
     *
     * @param [selector] Optional selector function to determine the value used to compare for equivalence.
     *
     * @returns Returns a new dataframe with groups of adjacent duplicate rows collapsed to a single row per group.
     *
     * @example
     * <pre>
     *
     * const dfWithDuplicateRowsRemoved = df.sequentialDistinct(row => row.ColumnA);
     * </pre>
     */
    sequentialDistinct<ToT = ValueT>(selector?: SelectorFn<ValueT, ToT>): IDataFrame<IndexT, ValueT>;
    /**
     * Aggregate the rows in the dataframe to a single result.
     *
     * @param [seed] Optional seed value for producing the aggregation.
     * @param selector Function that takes the seed and then each row in the dataframe and produces the aggregate value.
     *
     * @returns Returns a new value that has been aggregated from the dataframe using the 'selector' function.
     *
     * @example
     * <pre>
     *
     * const dailySalesDf = ... daily sales figures for the past month ...
     * const totalSalesForthisMonth = dailySalesDf.aggregate(
     *      0, // Seed - the starting value.
     *      (accumulator, row) => accumulator + row.SalesAmount // Aggregation function.
     * );
     * </pre>
     *
     * @example
     * <pre>
     *
     * const totalSalesAllTime = 500; // We'll seed the aggregation with this value.
     * const dailySalesDf = ... daily sales figures for the past month ...
     * const updatedTotalSalesAllTime = dailySalesDf.aggregate(
     *      totalSalesAllTime,
     *      (accumulator, row) => accumulator + row.SalesAmount
     * );
     * </pre>
     *
     * @example
     * <pre>
     *
     * var salesDataSummary = salesDataDf.aggregate({
     *      TotalSales: df => df.count(),
     *      AveragePrice: df => df.deflate(row => row.Price).average(),
     *      TotalRevenue: df => df.deflate(row => row.Revenue).sum(),
     * });
     * </pre>
    */
    aggregate<ToT = ValueT>(seedOrSelector: AggregateFn<ValueT, ToT> | ToT | IColumnAggregateSpec, selector?: AggregateFn<ValueT, ToT>): ToT;
    /**
     * Skip a number of rows in the dataframe.
     *
     * @param numValues Number of rows to skip.
     *
     * @returns Returns a new dataframe with the specified number of rows skipped.
     *
     * @example
     * <pre>
     *
     * const dfWithRowsSkipped = df.skip(10); // Skip 10 rows in the original dataframe.
     * </pre>
     */
    skip(numValues: number): IDataFrame<IndexT, ValueT>;
    /**
     * Skips values in the dataframe while a condition evaluates to true or truthy.
     *
     * @param predicate Returns true/truthy to continue to skip rows in the original dataframe.
     *
     * @returns Returns a new dataframe with all initial sequential rows removed while the predicate returned true/truthy.
     *
     * @example
     * <pre>
     *
     * const dfWithRowsSkipped = df.skipWhile(row => row.CustomerName === "Fred"); // Skip initial customers named Fred.
     * </pre>
     */
    skipWhile(predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Skips values in the dataframe untils a condition evaluates to true or truthy.
     *
     * @param predicate Return true/truthy to stop skipping rows in the original dataframe.
     *
     * @returns Returns a new dataframe with all initial sequential rows removed until the predicate returned true/truthy.
     *
     * @example
     * <pre>
     *
     * const dfWithRowsSkipped = df.skipUntil(row => row.CustomerName === "Fred"); // Skip initial customers until we find Fred.
     * </pre>
     */
    skipUntil(predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Take a number of rows in the dataframe.
     *
     * @param numValues Number of rows to take.
     *
     * @returns Returns a new dataframe with only the specified number of rows taken from the original dataframe.
     *
     * @example
     * <pre>
     *
     * const dfWithRowsTaken = df.take(15); // Take only the first 15 rows from the original dataframe.
     * </pre>
     */
    take(numRows: number): IDataFrame<IndexT, ValueT>;
    /**
     * Takes values from the dataframe while a condition evaluates to true or truthy.
     *
     * @param predicate Returns true/truthy to continue to take rows from the original dataframe.
     *
     * @returns Returns a new dataframe with only the initial sequential rows that were taken while the predicate returned true/truthy.
     *
     * @example
     * <pre>
     *
     * const dfWithRowsTaken = df.takeWhile(row => row.CustomerName === "Fred"); // Take only initial customers named Fred.
     * </pre>
     */
    takeWhile(predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Takes values from the dataframe untils a condition evaluates to true or truthy.
     *
     * @param predicate Return true/truthy to stop taking rows in the original dataframe.
     *
     * @returns Returns a new dataframe with only the initial sequential rows taken until the predicate returned true/truthy.
     *
     * @example
     * <pre>
     *
     * const dfWithRowsTaken = df.takeUntil(row => row.CustomerName === "Fred"); // Take all initial customers until we find Fred.
     * </pre>
     */
    takeUntil(predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Count the number of rows in the dataframe
     *
     * @returns Returns the count of all rows.
     *
     * @example
     * <pre>
     *
     * const numRows = df.count();
     * </pre>
     */
    count(): number;
    /**
     * Get the first row of the dataframe.
     *
     * @returns Returns the first row of the dataframe.
     *
     * @example
     * <pre>
     *
     * const firstRow = df.first();
     * </pre>
     */
    first(): ValueT;
    /**
     * Get the last row of the dataframe.
     *
     * @returns Returns the last row of the dataframe.
     *
     * @example
     * <pre>
     *
     * const lastRow = df.last();
     * </pre>
     */
    last(): ValueT;
    /**
     * Get the row, if there is one, with the specified index.
     *
     * @param index Index to for which to retreive the row.
     *
     * @returns Returns the row from the specified index in the dataframe or undefined if there is no such index in the present in the dataframe.
     *
     * @example
     * <pre>
     *
     * const row = df.at(5); // Get the row at index 5 (with a default 0-based index).
     * </pre>
     *
     * @example
     * <pre>
     *
     * const date = ... some date ...
     * // Retreive the row with specified date from a time-series dataframe (assuming date indexed has been applied).
     * const row = df.at(date);
     * </pre>
     */
    at(index: IndexT): ValueT | undefined;
    /**
     * Get X rows from the start of the dataframe.
     * Pass in a negative value to get all rows at the head except for X rows at the tail.
     *
     * @param numValues Number of rows to take.
     *
     * @returns Returns a new dataframe that has only the specified number of rows taken from the start of the original dataframe.
     *
     * @examples
     * <pre>
     *
     * const sample = df.head(10); // Take a sample of 10 rows from the start of the dataframe.
     * </pre>
     */
    head(numValues: number): IDataFrame<IndexT, ValueT>;
    /**
     * Get X rows from the end of the dataframe.
     * Pass in a negative value to get all rows at the tail except X rows at the head.
     *
     * @param numValues Number of rows to take.
     *
     * @returns Returns a new dataframe that has only the specified number of rows taken from the end of the original dataframe.
     *
     * @examples
     * <pre>
     *
     * const sample = df.tail(12); // Take a sample of 12 rows from the end of the dataframe.
     * </pre>
     */
    tail(numValues: number): IDataFrame<IndexT, ValueT>;
    /**
     * Filter the dataframe using user-defined predicate function.
     *
     * @param predicate Predicte function to filter rows from the dataframe. Returns true/truthy to keep rows, or false/falsy to omit rows.
     *
     * @returns Returns a new dataframe containing only the rows from the original dataframe that matched the predicate.
     *
     * @example
     * <pre>
     *
     * const filteredDf = df.where(row => row.CustomerName === "Fred"); // Filter so we only have customers named Fred.
     * </pre>
     */
    where(predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Invoke a callback function for each roew in the dataframe.
     *
     * @param callback The calback function to invoke for each row.
     *
     * @returns Returns the original dataframe with no modifications.
     *
     * @example
     * <pre>
     *
     * df.forEach(row => {
     *      // ... do something with the row ...
     * });
     * </pre>
     */
    forEach(callback: CallbackFn<ValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Evaluates a predicate function for every row in the dataframe to determine
     * if some condition is true/truthy for **all** rows in the dataframe.
     *
     * @param predicate Predicate function that receives each row. It should returns true/truthy for a match, otherwise false/falsy.
     *
     * @returns Returns true if the predicate has returned true or truthy for every row in the dataframe, otherwise returns false. Returns false for an empty dataframe.
     *
     * @example
     * <pre>
     *
     * const everyoneIsNamedFred = df.all(row => row.CustomerName === "Fred"); // Check if all customers are named Fred.
     * </pre>
     */
    all(predicate: PredicateFn<ValueT>): boolean;
    /**
     * Evaluates a predicate function for every row in the dataframe to determine
     * if some condition is true/truthy for **any** of rows in the dataframe.
     *
     * If no predicate is specified then it simply checks if the dataframe contains more than zero rows.
     *
     * @param [predicate] Optional predicate function that receives each row. It should return true/truthy for a match, otherwise false/falsy.
     *
     * @returns Returns true if the predicate has returned truthy for any row in the sequence, otherwise returns false.
     * If no predicate is passed it returns true if the dataframe contains any rows at all.
     * Returns false for an empty dataframe.
     *
     * @example
     * <pre>
     *
     * const anyFreds = df.any(row => row.CustomerName === "Fred"); // Do we have any customers named Fred?
     * </pre>
     *
     * @example
     * <pre>
     *
     * const anyCustomers = df.any(); // Do we have any customers at all?
     * </pre>
     */
    any(predicate?: PredicateFn<ValueT>): boolean;
    /**
     * Evaluates a predicate function for every row in the dataframe to determine
     * if some condition is true/truthy for **none** of rows in the dataframe.
     *
     * If no predicate is specified then it simply checks if the dataframe contains zero rows.
     *
     * @param [predicate] Optional predicate function that receives each row. It should return true/truthy for a match, otherwise false/falsy.
     *
     * @returns Returns true if the predicate has returned truthy for zero rows in the dataframe, otherwise returns false. Returns false for an empty dataframe.
     *
     * @example
     * <pre>
     *
     * const noFreds = df.none(row => row.CustomerName === "Fred"); // Do we have zero customers named Fred?
     * </pre>
     *
     * @example
     * <pre>
     *
     * const noCustomers = df.none(); // Do we have zero customers?
     * </pre>
     */
    none(predicate?: PredicateFn<ValueT>): boolean;
    /**
     * Gets a new dataframe containing all rows starting at and after the specified index value.
     *
     * @param indexValue The index value at which to start the new dataframe.
     *
     * @returns Returns a new dataframe containing all rows starting at and after the specified index value.
     *
     * @example
     * <pre>
     *
     * const df = new DataFrame({
     *      index: [0, 1, 2, 3], // This is the default index.
     *      values: [10, 20, 30, 40],
     * });
     *
     * const lastHalf = df.startAt(2);
     * expect(lastHalf.toArray()).to.eql([30, 40]);
     * </pre>
     *
     * @example
     * <pre>
     *
     * const timeSeriesDf = ... a dataframe indexed by date/time ...
     *
     * // Get all rows starting at (or after) a particular date.
     * const allRowsFromStartDate = df.startAt(new Date(2016, 5, 4));
     * </pre>
     */
    startAt(indexValue: IndexT): IDataFrame<IndexT, ValueT>;
    /**
     * Gets a new dataframe containing all rows up until and including the specified index value (inclusive).
     *
     * @param indexValue The index value at which to end the new dataframe.
     *
     * @returns Returns a new dataframe containing all rows up until and including the specified index value.
     *
     * @example
     * <pre>
     *
     * const df = new DataFrame({
     *      index: [0, 1, 2, 3], // This is the default index.
     *      values: [10, 20, 30, 40],
     * });
     *
     * const firstHalf = df.endAt(1);
     * expect(firstHalf.toArray()).to.eql([10, 20]);
     * </pre>
     *
     * @example
     * <pre>
     *
     * const timeSeriesDf = ... a dataframe indexed by date/time ...
     *
     * // Get all rows ending at a particular date.
     * const allRowsUpToAndIncludingTheExactEndDate = df.endAt(new Date(2016, 5, 4));
     * </pre>
     */
    endAt(indexValue: IndexT): IDataFrame<IndexT, ValueT>;
    /**
     * Gets a new dataframe containing all rows up to the specified index value (exclusive).
     *
     * @param indexValue The index value at which to end the new dataframe.
     *
     * @returns Returns a new dataframe containing all rows up to (but not including) the specified index value.
     *
     * @example
     * <pre>
     *
     * const df = new DataFrame({
     *      index: [0, 1, 2, 3], // This is the default index.
     *      values: [10, 20, 30, 40],
     * });
     *
     * const firstHalf = df.before(2);
     * expect(firstHalf.toArray()).to.eql([10, 20]);
     * </pre>
     *
     * @example
     * <pre>
     *
     * const timeSeriesDf = ... a dataframe indexed by date/time ...
     *
     * // Get all rows before the specified date.
     * const allRowsBeforeEndDate = df.before(new Date(2016, 5, 4));
     * </pre>
     */
    before(indexValue: IndexT): IDataFrame<IndexT, ValueT>;
    /**
     * Gets a new dataframe containing all rows after the specified index value (exclusive).
     *
     * @param indexValue The index value after which to start the new dataframe.
     *
     * @returns Returns a new dataframe containing all rows after the specified index value.
     *
     * @example
     * <pre>
     *
     * const df = new DataFrame({
     *      index: [0, 1, 2, 3], // This is the default index.
     *      values: [10, 20, 30, 40],
     * });
     *
     * const lastHalf = df.before(1);
     * expect(lastHalf.toArray()).to.eql([30, 40]);
     * </pre>
     *
     * @example
     * <pre>
     *
     * const timeSeriesDf = ... a dataframe indexed by date/time ...
     *
     * // Get all rows after the specified date.
     * const allRowsAfterStartDate = df.after(new Date(2016, 5, 4));
     * </pre>
     */
    after(indexValue: IndexT): IDataFrame<IndexT, ValueT>;
    /**
     * Gets a new dataframe containing all rows between the specified index values (inclusive).
     *
     * @param startIndexValue The index at which to start the new dataframe.
     * @param endIndexValue The index at which to end the new dataframe.
     *
     * @returns Returns a new dataframe containing all values between the specified index values (inclusive).
     *
     * @example
     * <pre>
     *
     * const df = new DataFrame({
     *      index: [0, 1, 2, 3, 4, 6], // This is the default index.
     *      values: [10, 20, 30, 40, 50, 60],
     * });
     *
     * const middleSection = df.between(1, 4);
     * expect(middleSection.toArray()).to.eql([20, 30, 40, 50]);
     * </pre>
     *
     * @example
     * <pre>
     *
     * const timeSeriesDf = ... a dataframe indexed by date/time ...
     *
     * // Get all rows between the start and end dates (inclusive).
     * const allRowsBetweenDates = df.after(new Date(2016, 5, 4), new Date(2016, 5, 22));
     * </pre>
     */
    between(startIndexValue: IndexT, endIndexValue: IndexT): IDataFrame<IndexT, ValueT>;
    /**
     * Format the dataframe for display as a string.
     * This forces lazy evaluation to complete.
     *
     * @returns Generates and returns a string representation of the dataframe or dataframe.
     *
     * @example
     * <pre>
     *
     * console.log(df.toString());
     * </pre>
     */
    toString(): string;
    /**
     * Parse a column with string values and convert it to a column with int values.
     *
     * @param columnNameOrNames Specifies the column name or array of column names to parse.
     *
     * @returns Returns a new dataframe with a particular named column parsed as ints.
     *
     * @example
     * <pre>
     *
     * const withParsedColumn = df.parseInts("MyIntColumn");
     * </pre>
     *
     * @example
     * <pre>
     *
     * const withParsedColumns = df.parseInts(["MyIntColumnA", "MyIntColumnA"]);
     * </pre>
     */
    parseInts(columnNameOrNames: string | string[]): IDataFrame<IndexT, ValueT>;
    /**
     * Parse a column with string values and convert it to a column with float values.
     *
     * @param columnNameOrNames Specifies the column name or array of column names to parse.
     *
     * @returns  Returns a new dataframe with a particular named column parsed as floats.
     *
     * @example
     * <pre>
     *
     * const withParsedColumn = df.parseFloats("MyFloatColumn");
     * </pre>
     *
     * @example
     * <pre>
     *
     * const withParsedColumns = df.parseFloats(["MyFloatColumnA", "MyFloatColumnA"]);
     * </pre>
     */
    parseFloats(columnNameOrNames: string | string[]): IDataFrame<IndexT, ValueT>;
    /**
     * Parse a column with string values and convert it to a column with date values.
     *
     * @param columnNameOrNames -Specifies the column name or array of column names to parse.
     * @param [formatString] Optional formatting string for dates.
     *
     * @returns Returns a new dataframe with a particular named column parsed as dates.
     *
     * @example
     * <pre>
     *
     * const withParsedColumn = df.parseDates("MyDateColumn");
     * </pre>
     *
     * @example
     * <pre>
     *
     * const withParsedColumns = df.parseDates(["MyDateColumnA", "MyDateColumnA"]);
     * </pre>
     */
    parseDates(columnNameOrNames: string | string[], formatString?: string): IDataFrame<IndexT, ValueT>;
    /**
     * Convert a column of values of different types to a column of string values.
     *
     * @param columnNames Specifies the column name or array of column names to convert to strings. Can also be a format spec that specifies which columns to convert and what their format should be.
     * @param [formatString] Optional formatting string for dates.
     *
     * Numeral.js is used for number formatting.
     * http://numeraljs.com/
     *
     * Moment is used for date formatting.
     * https://momentjs.com/docs/#/parsing/string-format/
     *
     * @returns Returns a new dataframe with a particular named column convert to strings.
     *
     * @example
     * <pre>
     *
     * const withStringColumn = df.toStrings("MyDateColumn", "YYYY-MM-DD");
     * </pre>
     *
     * @example
     * <pre>
     *
     * const withStringColumn = df.toStrings("MyFloatColumn", "0.00");
     * </pre>
     */
    toStrings(columnNames: string | string[] | IFormatSpec, formatString?: string): IDataFrame<IndexT, ValueT>;
    /**
     * Produces a new dataframe with all string values truncated to the requested maximum length.
     *
     * @param maxLength The maximum length of the string values after truncation.
     *
     * @returns Returns a new dataframe with all strings truncated to the specified maximum length.
     *
     * @example
     * <pre>
     *
     * // Truncate all string columns to 100 characters maximum.
     * const truncatedDf = df.truncateString(100);
     * </pre>
     */
    truncateStrings(maxLength: number): IDataFrame<IndexT, ValueT>;
    /**
     * Forces lazy evaluation to complete and 'bakes' the dataframe into memory.
     *
     * @returns Returns a dataframe that has been 'baked', all lazy evaluation has completed.
     *
     * @example
     * <pre>
     *
     * const bakedDf = df.bake();
     * </pre>
     */
    bake(): IDataFrame<IndexT, ValueT>;
    /**
     * Gets a new dataframe in reverse order.
     *
     * @returns Returns a new dataframe that is the reverse of the input.
     *
     * @example
     * <pre>
     *
     * const reversedDf = df.reverse();
     * </pre>
     */
    reverse(): IDataFrame<IndexT, ValueT>;
    /**
     * Returns only the set of rows in the dataframe that are distinct according to some criteria.
     * This can be used to remove duplicate rows from the dataframe.
     *
     * @param selector User-defined selector function that specifies the criteria used to make comparisons for duplicate rows.
     *
     * @returns Returns a dataframe containing only unique values as determined by the 'selector' function.
     *
     * @example
     * <pre>
     *
     * // Remove duplicate rows by customer id. Will return only a single row per customer.
     * const distinctCustomers = salesDf.distinct(sale => sale.CustomerId);
     * </pre>
     */
    distinct<ToT>(selector?: SelectorFn<ValueT, ToT>): IDataFrame<IndexT, ValueT>;
    /**
     * Collects rows in the dataframe into a series of groups according to the user-defined selector function that defines the group for each row.
     *
     * @param selector User-defined selector function that defines the value to group by.
     *
     * @returns Returns a {@link Series} of groups. Each group is a dataframe with values that have been grouped by the 'selector' function.
     *
     * @example
     * <pre>
     *
     * const salesDf = ... product sales ...
     * const salesByProduct = salesDf.groupBy(sale => sale.ProductId);
     * for (const productSalesGroup of salesByProduct) {
     *      // ... do something with each product group ...
     *      const productId = productSalesGroup.first().ProductId;
     *      const totalSalesForProduct = productSalesGroup.deflate(sale => sale.Amount).sum();
     *      console.log(totalSalesForProduct);
     * }
     * </pre>
     */
    groupBy<GroupT>(selector: SelectorWithIndexFn<ValueT, GroupT>): ISeries<number, IDataFrame<IndexT, ValueT>>;
    /**
     * Collects rows in the dataframe into a series of groups according to a user-defined selector function that identifies adjacent rows that should be in the same group.
     *
     * @param selector Optional selector that defines the value to group by.
     *
     * @returns Returns a {@link Series} of groups. Each group is a dataframe with values that have been grouped by the 'selector' function.
     *
     * @example
     * <pre>
     *
     * // Some ultra simple stock trading strategy backtesting...
     * const dailyStockPriceDf = ... daily stock price for a company ...
     * const priceGroups  = dailyStockPriceDf.groupBy(day => day.close > day.movingAverage);
     * for (const priceGroup of priceGroups) {
     *      // ... do something with each stock price group ...
     *
     *      const firstDay = priceGroup.first();
     *      if (firstDay.close > movingAverage) {
     *          // This group of days has the stock price above its moving average.
     *          // ... maybe enter a long trade here ...
     *      }
     *      else {
     *          // This group of days has the stock price below its moving average.
     *          // ... maybe enter a short trade here ...
     *      }
     * }
     * </pre>
     */
    groupSequentialBy<GroupT>(selector?: SelectorFn<ValueT, GroupT>): ISeries<number, IDataFrame<IndexT, ValueT>>;
    /**
     * Concatenate multiple dataframes into a single dataframe.
     *
     * @param dataframes Array of dataframes to concatenate.
     *
     * @returns Returns a single dataframe concatenated from multiple input dataframes.
     *
     * @example
     * <pre>
     *
     * const df1 = ...
     * const df2 = ...
     * const df3 = ...
     * const concatenatedDf = DataFrame.concat([df1, df2, df3]);
     * </pre>
     *
     * @example
     * <pre>
     *
     * const dfs = [... array of dataframes...];
     * const concatenatedDf = DataFrame.concat(dfs);
     * </pre>
     */
    static concat<IndexT = any, ValueT = any>(dataframes: IDataFrame<IndexT, ValueT>[]): IDataFrame<IndexT, ValueT>;
    /**
     * Concatenate multiple other dataframes onto this dataframe.
     *
     * @param dataframes Multiple arguments. Each can be either a dataframe or an array of dataframes.
     *
     * @returns Returns a single dataframes concatenated from multiple input dataframes.
     *
     * @example
     * <pre>
     *
     * const concatenatedDf = dfA.concat(dfB);
     * </pre>
     *
     * @example
     * <pre>
     *
     * const concatenatedDf = dfA.concat(dfB, dfC);
     * </pre>
     *
     * @example
     * <pre>
     *
     * const concatenatedDf = dfA.concat([dfB, dfC]);
     * </pre>
     *
     * @example
     * <pre>
     *
     * const concatenatedDf = dfA.concat(dfB, [dfC, dfD]);
     * </pre>
     *
     * @example
     * <pre>
     *
     * const otherDfs = [... array of dataframes...];
     * const concatenatedDf = dfA.concat(otherDfs);
     * </pre>
     */
    concat(...dataframes: (IDataFrame<IndexT, ValueT>[] | IDataFrame<IndexT, ValueT>)[]): IDataFrame<IndexT, ValueT>;
    /**
    * Zip (or merge) together multiple dataframes to create a new dataframe.
    * Preserves the index of the first dataframe.
    *
    * @param dataframes Array of input dataframes to be zipped together.
    * @param zipper User-defined zipper function that merges rows. It produces rows for the new dataframe based-on rows from the input dataframes.
    *
    * @returns Returns a single dataframe zipped (or merged) from multiple input dataframes.
    *
    * @example
    * <pre>
    *
    * function produceNewRow (rowA, rowB) {
    *       const outputRow = {
    *           // Produce output row based on the contents of the input rows.
    *       };
    *       return outputRow;
    * }
    *
    * const inputDfs = [... array of input dataframes ...];
    * const zippedDf = DataFrame.zip(inputDfs, produceNewRow);
    *
    * </pre>
    *
    * @example
    * <pre>
    *
    * function produceNewRow (rowA, rowB) {
    *       const outputRow = {
    *           ValueA: rowA.Value,
    *           ValueB: rowB.Value,
    *       };
    *       return outputRow;
    * }
    *
    * const dfA = new DataFrame([ { Value: 10 }, { Value: 20 }, { Value: 30 }]);
    * const dfB = new DataFrame([ { Value: 100 }, { Value: 200 }, { Value: 300 }]);
    * const zippedDf = DataFrame.zip([dfA, dfB], produceNewRow);
    * </pre>
    */
    static zip<IndexT = any, ValueT = any, ResultT = any>(dataframes: IDataFrame<IndexT, ValueT>[], zipper: ZipNFn<ValueT, ResultT>): IDataFrame<IndexT, ResultT>;
    /**
    * Zip (or merge) together multiple dataframes to create a new dataframe.
    * Preserves the index of the first dataframe.
    *
    * @param s2, s3, s4, s4 Multiple dataframes to zip.
    * @param zipper User-defined zipper function that merges rows. It produces rows for the new dataframe based-on rows from the input dataframes.
    *
    * @returns Returns a single dataframe zipped (or merged) from multiple input dataframes.
    *
    * @example
    * <pre>
    *
    * function produceNewRow (rowA, rowB) {
    *       const outputRow = {
    *           ValueA: rowA.Value,
    *           ValueB: rowB.Value,
    *       };
    *       return outputRow;
    * }
    *
    * const dfA = new DataFrame([ { Value: 10 }, { Value: 20 }, { Value: 30 }]);
    * const dfB = new DataFrame([ { Value: 100 }, { Value: 200 }, { Value: 300 }]);
    * const zippedDf = dfA.zip(dfB, produceNewRow);
    * </pre>
    */
    zip<Index2T, Value2T, ResultT>(s2: IDataFrame<Index2T, Value2T>, zipper: Zip2Fn<ValueT, Value2T, ResultT>): IDataFrame<IndexT, ResultT>;
    zip<Index2T, Value2T, Index3T, Value3T, ResultT>(s2: IDataFrame<Index2T, Value2T>, s3: IDataFrame<Index3T, Value3T>, zipper: Zip3Fn<ValueT, Value2T, Value3T, ResultT>): IDataFrame<IndexT, ResultT>;
    zip<Index2T, Value2T, Index3T, Value3T, Index4T, Value4T, ResultT>(s2: IDataFrame<Index2T, Value2T>, s3: IDataFrame<Index3T, Value3T>, s4: IDataFrame<Index4T, Value4T>, zipper: Zip3Fn<ValueT, Value2T, Value3T, ResultT>): IDataFrame<IndexT, ResultT>;
    /**
     * Sorts the dataframe in ascending order by a value defined by the user-defined selector function.
     *
     * @param selector User-defined selector function that selects the value to sort by.
     *
     * @returns Returns a new dataframe that has been ordered accorrding to the value chosen by the selector function.
     *
     * @example
     * <pre>
     *
     * // Order sales by amount from least to most.
     * const orderedDf = salesDf.orderBy(sale => sale.Amount);
     * </pre>
     */
    orderBy<SortT>(selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedDataFrame<IndexT, ValueT, SortT>;
    /**
     * Sorts the dataframe in descending order by a value defined by the user-defined selector function.
     *
     * @param selector User-defined selector function that selects the value to sort by.
     *
     * @returns Returns a new dataframe that has been ordered accorrding to the value chosen by the selector function.
     *
     * @example
     * <pre>
     *
     * // Order sales by amount from most to least
     * const orderedDf = salesDf.orderByDescending(sale => sale.Amount);
     * </pre>
     */
    orderByDescending<SortT>(selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedDataFrame<IndexT, ValueT, SortT>;
    /**
     * Creates a new dataframe by merging two input dataframes.
     * The resulting dataframe contains the union of rows from the two input dataframes.
     * These are the unique combination of rows in both dataframe.
     * This is basically a concatenation and then elimination of duplicates.
     *
     * @param other The other dataframes to merge.
     * @param [selector] Optional user-defined selector function that selects the value to compare to detemrine distinctness.
     *
     * @returns Returns the union of the two dataframes.
     *
     * @example
     * <pre>
     *
     * const dfA = ...
     * const dfB = ...
     * const merged = dfA.union(dfB);
     * </pre>
     *
     * @example
     * <pre>
     *
     * // Merge two sets of customer records that may contain the same
     * // customer record in each set. This is basically a concatenation
     * // of the dataframes and then an elimination of any duplicate records
     * // that result.
     * const customerRecordsA = ...
     * const customerRecordsB = ...
     * const mergedCustomerRecords = customerRecordsA.union(
     *      customerRecordsB,
     *      customerRecord => customerRecord.CustomerId
     * );
     * </pre>
     *
     *
     * @example
     * <pre>
     *
     * // Note that you can achieve the exact same result as the previous
     * // example by doing a {@link DataFrame.concat) and {@link DataFrame.distinct}
     * // of the dataframes and then an elimination of any duplicate records
     * // that result.
     * const customerRecordsA = ...
     * const customerRecordsB = ...
     * const mergedCustomerRecords = customerRecordsA
     *      .concat(customerRecordsB)
     *      .distinct(customerRecord => customerRecord.CustomerId);
     * </pre>
     *
     */
    union<KeyT = ValueT>(other: IDataFrame<IndexT, ValueT>, selector?: SelectorFn<ValueT, KeyT>): IDataFrame<IndexT, ValueT>;
    /**
     * Creates a new dataframe by merging two input dataframes.
     * The resulting dataframe contains the intersection of rows from the two input dataframes.
     * These are only the rows that appear in both dataframes.
     *
     * @param inner The inner dataframe to merge (the dataframe you call the function on is the 'outer' dataframe).
     * @param [outerSelector] Optional user-defined selector function that selects the key from the outer dataframe that is used to match the two dataframes.
     * @param [innerSelector] Optional user-defined selector function that selects the key from the inner dataframe that is used to match the two dataframes.
     *
     * @returns Returns a new dataframe that contains the intersection of rows from the two input dataframes.
     *
     * @example
     * <pre>
     *
     * const dfA = ...
     * const dfB = ...
     * const mergedDf = dfA.intersection(dfB);
     * </pre>
     *
     * @example
     * <pre>
     *
     * // Merge two sets of customer records to find only the
     * // customers that appears in both.
     * const customerRecordsA = ...
     * const customerRecordsB = ...
     * const intersectionOfCustomerRecords = customerRecordsA.intersection(
     *      customerRecordsB,
     *      customerRecord => customerRecord.CustomerId
     * );
     * </pre>
     * */
    intersection<InnerIndexT = IndexT, InnerValueT = ValueT, KeyT = ValueT>(inner: IDataFrame<InnerIndexT, InnerValueT>, outerSelector?: SelectorFn<ValueT, KeyT>, innerSelector?: SelectorFn<InnerValueT, KeyT>): IDataFrame<IndexT, ValueT>;
    /**
     * Creates a new dataframe by merging two input dataframes.
     * The resulting dataframe contains only the rows from the 1st dataframe that don't appear in the 2nd dataframe.
     * This is essentially subtracting the rows from the 2nd dataframe from the 1st and creating a new dataframe with the remaining rows.
     *
     * @param inner The inner dataframe to merge (the dataframe you call the function on is the 'outer' dataframe).
     * @param [outerSelector] Optional user-defined selector function that selects the key from the outer dataframe that is used to match the two dataframes.
     * @param [innerSelector] Optional user-defined selector function that selects the key from the inner dataframe that is used to match the two dataframes.
     *
     * @returns Returns a new dataframe that contains only the rows from the 1st dataframe that don't appear in the 2nd dataframe.
     *
     * @example
     * <pre>
     *
     * const dfA = ...
     * const dfB = ...
     * const remainingDf = dfA.except(dfB);
     * </pre>
     *
     * @example
     * <pre>
     *
     * // Find the list of customers haven't bought anything recently.
     * const allCustomers = ... list of all customers ...
     * const recentCustomers = ... list of customers who have purchased recently ...
     * const remainingCustomers = allCustomers.except(
     *      recentCustomers,
     *      customerRecord => customerRecord.CustomerId
     * );
     * </pre>
     */
    except<InnerIndexT = IndexT, InnerValueT = ValueT, KeyT = ValueT>(inner: IDataFrame<InnerIndexT, InnerValueT>, outerSelector?: SelectorFn<ValueT, KeyT>, innerSelector?: SelectorFn<InnerValueT, KeyT>): IDataFrame<IndexT, ValueT>;
    /**
      * Creates a new dataframe by merging two input dataframes.
      * The resulting dataframe contains only those rows that have matching keys in both input dataframes.
      *
      * @param inner The 'inner' dataframe to join (the dataframe you are callling the function on is the 'outer' dataframe).
      * @param outerKeySelector User-defined selector function that chooses the join key from the outer dataframe.
      * @param innerKeySelector User-defined selector function that chooses the join key from the inner dataframe.
      * @param resultSelector User-defined function that merges outer and inner values.
      *
      * @returns Returns the new merged dataframe.
      *
      * @example
      * <pre>
      *
      * // Join together two sets of customers to find those
      * // that have bought both product A and product B.
      * const customerWhoBoughtProductA = ...
      * const customerWhoBoughtProductB = ...
      * const customersWhoBoughtBothProductsDf = customerWhoBoughtProductA.join(
      *          customerWhoBoughtProductB,
      *          customerA => customerA.CustomerId, // Join key.
      *          customerB => customerB.CustomerId, // Join key.
      *          (customerA, customerB) => {
      *              return {
      *                  // ... merge the results ...
      *              };
      *          }
      *      );
      * </pre>
      */
    join<KeyT, InnerIndexT, InnerValueT, ResultValueT>(inner: IDataFrame<InnerIndexT, InnerValueT>, outerKeySelector: SelectorFn<ValueT, KeyT>, innerKeySelector: SelectorFn<InnerValueT, KeyT>, resultSelector: JoinFn<ValueT, InnerValueT, ResultValueT>): IDataFrame<number, ResultValueT>;
    /**
     * Creates a new dataframe by merging two input dataframes.
     * The resulting dataframe contains only those rows that are only present in or or the other of the dataframes, not both.
     *
     * @param inner The 'inner' dataframe to join (the dataframe you are callling the function on is the 'outer' dataframe).
     * @param outerKeySelector User-defined selector function that chooses the join key from the outer dataframe.
     * @param innerKeySelector User-defined selector function that chooses the join key from the inner dataframe.
     * @param resultSelector User-defined function that merges outer and inner values.
     *
     * Implementation from here:
     *
     * 	http://blogs.geniuscode.net/RyanDHatch/?p=116
     *
     * @returns Returns the new merged dataframe.
     *
     * @example
     * <pre>
     *
     * // Join together two sets of customers to find those
     * // that have bought either product A or product B, not not both.
     * const customerWhoBoughtProductA = ...
     * const customerWhoBoughtProductB = ...
     * const customersWhoBoughtEitherProductButNotBothDf = customerWhoBoughtProductA.joinOuter(
     *          customerWhoBoughtProductB,
     *          customerA => customerA.CustomerId, // Join key.
     *          customerB => customerB.CustomerId, // Join key.
     *          (customerA, customerB) => {
     *              return {
     *                  // ... merge the results ...
     *              };
     *          }
     *      );
     * </pre>
     */
    joinOuter<KeyT, InnerIndexT, InnerValueT, ResultValueT>(inner: IDataFrame<InnerIndexT, InnerValueT>, outerKeySelector: SelectorFn<ValueT, KeyT>, innerKeySelector: SelectorFn<InnerValueT, KeyT>, resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>): IDataFrame<number, ResultValueT>;
    /**
     * Creates a new dataframe by merging two input dataframes.
     * The resulting dataframe contains only those rows that present either in both dataframes or only in the outer (left) dataframe.
     *
     * @param inner The 'inner' dataframe to join (the dataframe you are callling the function on is the 'outer' dataframe).
     * @param outerKeySelector User-defined selector function that chooses the join key from the outer dataframe.
     * @param innerKeySelector User-defined selector function that chooses the join key from the inner dataframe.
     * @param resultSelector User-defined function that merges outer and inner values.
     *
     * Implementation from here:
     *
     * 	http://blogs.geniuscode.net/RyanDHatch/?p=116
     *
     * @returns Returns the new merged dataframe.
     *
     * @example
     * <pre>
     *
     * // Join together two sets of customers to find those
     * // that have bought either just product A or both product A and product B.
     * const customerWhoBoughtProductA = ...
     * const customerWhoBoughtProductB = ...
     * const boughtJustAorAandB = customerWhoBoughtProductA.joinOuterLeft(
     *          customerWhoBoughtProductB,
     *          customerA => customerA.CustomerId, // Join key.
     *          customerB => customerB.CustomerId, // Join key.
     *          (customerA, customerB) => {
     *              return {
     *                  // ... merge the results ...
     *              };
     *          }
     *      );
     * </pre>
     */
    joinOuterLeft<KeyT, InnerIndexT, InnerValueT, ResultValueT>(inner: IDataFrame<InnerIndexT, InnerValueT>, outerKeySelector: SelectorFn<ValueT, KeyT>, innerKeySelector: SelectorFn<InnerValueT, KeyT>, resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>): IDataFrame<number, ResultValueT>;
    /**
     * Creates a new dataframe by merging two input dataframes.
     * The resulting dataframe contains only those rows that present either in both dataframes or only in the inner (right) dataframe.
     *
     * @param inner The 'inner' dataframe to join (the dataframe you are callling the function on is the 'outer' dataframe).
     * @param outerKeySelector User-defined selector function that chooses the join key from the outer dataframe.
     * @param innerKeySelector User-defined selector function that chooses the join key from the inner dataframe.
     * @param resultSelector User-defined function that merges outer and inner values.
     *
     * Implementation from here:
     *
     * 	http://blogs.geniuscode.net/RyanDHatch/?p=116
     *
     * @returns Returns the new merged dataframe.
     *
     * @example
     * <pre>
     *
     * // Join together two sets of customers to find those
     * // that have bought either just product B or both product A and product B.
     * const customerWhoBoughtProductA = ...
     * const customerWhoBoughtProductB = ...
     * const boughtJustAorAandB = customerWhoBoughtProductA.joinOuterRight(
     *          customerWhoBoughtProductB,
     *          customerA => customerA.CustomerId, // Join key.
     *          customerB => customerB.CustomerId, // Join key.
     *          (customerA, customerB) => {
     *              return {
     *                  // ... merge the results ...
     *              };
     *          }
     *      );
     * </pre>
     */
    joinOuterRight<KeyT, InnerIndexT, InnerValueT, ResultValueT>(inner: IDataFrame<InnerIndexT, InnerValueT>, outerKeySelector: SelectorFn<ValueT, KeyT>, innerKeySelector: SelectorFn<InnerValueT, KeyT>, resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>): IDataFrame<number, ResultValueT>;
    /**
     * Reshape (or pivot) a table based on column values.
     * This effiectively a short-hand for multiple grouping operations and an aggregation.
     *
     * @param columnOrColumns - Column name whose values make the new DataFrame's columns.
     * @param valueColumnNameOrSpec - Column name or column spec that defines the columns whose values should be aggregated.
     * @param [aggregator] - Optional function used to aggregate pivotted vales.
     *
     * @returns Returns a new dataframe that has been pivoted based on a particular column's values.
     */
    pivot<NewValueT = ValueT>(columnOrColumns: string | Iterable<string>, valueColumnNameOrSpec: string | IPivotAggregateSpec, aggregator?: (values: ISeries<number, any>) => any): IDataFrame<number, NewValueT>;
    /**
     * Insert a pair at the start of the dataframe.
     *
     * @param pair - The pair to insert.
     *
     * @returns Returns a new dataframe with the specified pair inserted.
     */
    insertPair(pair: [IndexT, ValueT]): IDataFrame<IndexT, ValueT>;
    /**
     * Append a pair to the end of a dataframe.
     *
     * @param pair - The pair to append.
     *
     * @returns Returns a new dataframe with the specified pair appended.
     */
    appendPair(pair: [IndexT, ValueT]): IDataFrame<IndexT, ValueT>;
    /**
     * Fill gaps in a dataframe.
     *
     * @param comparer - Comparer that is passed pairA and pairB, two consecutive rows, return truthy if there is a gap between the rows, or falsey if there is no gap.
     * @param generator - Generator that is passed pairA and pairB, two consecutive rows, returns an array of pairs that fills the gap between the rows.
     *
     * @returns Returns a new dataframe with gaps filled in.
     */
    fillGaps(comparer: ComparerFn<[IndexT, ValueT], [IndexT, ValueT]>, generator: GapFillFn<[IndexT, ValueT], [IndexT, ValueT]>): IDataFrame<IndexT, ValueT>;
    /**
     * Returns the specified default sequence if the dataframe is empty.
     *
     * @param defaultSequence - Default sequence to return if the dataframe is empty.
     *
     * @returns Returns 'defaultSequence' if the dataframe is empty.
     */
    defaultIfEmpty(defaultSequence: ValueT[] | IDataFrame<IndexT, ValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Detect the the frequency of the types of the values in the dataframe.
     *
     * @returns Returns a dataframe that describes the data types contained in the dataframe.
     */
    detectTypes(): IDataFrame<number, ITypeFrequency>;
    /**
     * Detect the frequency of the values in the dataframe.
     *
     * @returns Returns a dataframe that describes the values contained in the dataframe.
     */
    detectValues(): IDataFrame<number, IValueFrequency>;
    /**
     * Serialize the dataframe to JSON.
     *
     *  @returns Returns a JSON format string representing the dataframe.
     */
    toJSON(): string;
    /**
     * Serialize the dataframe to CSV.
     *
     *  @returns Returns a CSV format string representing the dataframe.
     */
    toCSV(): string;
    /**
     * Treat the dataframe as CSV data for purposes of serialization.
     *
     * @returns Returns an object that represents the dataframe for serialization in the CSV format. Call `writeFile`, `writeFileSync` to output the dataframe via different media.
     */
    asCSV(): ICsvSerializer;
    /**
     * Treat the dataframe as JSON data for purposes of serialization.
     *
     * @returns Returns an object that can serialize the dataframe in the JSON format. Call `writeFile` or `writeFileSync` to output the dataframe via different media.
     */
    asJSON(): IJsonSerializer;
    /**
     * Serialize the data frame to HTML.
     *
     *  @returns Returns a HTML format string representing the dataframe.
     */
    toHTML(): string;
    /**
     * Serialize the dataframe to an ordinary JavaScript data structure.
     */
    serialize(): ISerializedDataFrame;
    /**
     * Deserialize the dataframe from an ordinary JavaScript data structure.
     */
    static deserialize<IndexT = any, ValueT = any>(input: ISerializedDataFrame): IDataFrame<IndexT, ValueT>;
    getTypeCode(): string;
}
/**
 * Packages a dataframe ready for CSV serialization.
 * */
export interface ICsvSerializer {
    /**
     * Serialize the dataframe to a CSV file in the local file system.
     * Asynchronous version.
     *
     * @param filePath - Specifies the output path for the file.
     *
     *  @returns Returns a promise that resolves when the file has been written.
     */
    writeFile(filePath: string): Promise<void>;
    /**
     * Serialize the dataframe to a CSV file in the local file system.
     * Synchronous version.
     *
     * @param filePath - Specifies the output path for the file.
     */
    writeFileSync(filePath: string): void;
}
/**
 * Packages a dataframe ready for JSON serialization.
 */
export interface IJsonSerializer {
    /**
     * Serialize the dataframe to a JSON file in the local file system.
     * Asynchronous version.
     *
     * @param filePath - Specifies the output path for the file.
     *
     *  @returns Returns a promise that resolves when the file has been written.
     */
    writeFile(filePath: string): Promise<void>;
    /**
     * Serialize the dataframe to a JSON file in the local file system.
     * Synchronous version.
     *
     * @param filePath - Specifies the output path for the file.
     */
    writeFileSync(filePath: string): void;
}
